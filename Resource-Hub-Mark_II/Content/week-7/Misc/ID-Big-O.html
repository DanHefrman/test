<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ID-Big-O</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="identifying-time-complexity"><strong>Identifying Time Complexity</strong></h1>
<hr />
<h1 id="constant"><strong>Constant</strong></h1>
<ul>
<li><p>Takes roughly the same number of steps for any input size.</p>
<p>function constant1(n) { return n * 2 + 1; } // always takes one step regardless of n’s value.</p>
<p>function constant2(n) { for (let i = 1; i &lt;= 100; i++) { console.log(i); } } // always loops 100 times regardless of input n.</p>
<p>function returnFirst(array) { return array[0]; }</p></li>
</ul>
<h1 id="logarithmic"><strong>Logarithmic</strong></h1>
<ul>
<li>Halves the size of the input.</li>
<li>Exponential is the inverse of log.</li>
<li><p>Typically Divide and Conquer Style Algorithms</p>
<p>function log(n) { if (n &lt;= 1) return; log(n / 2); } // recursively calling log function again but dividing input by 2 every time.</p>
<p>function log(n) { let i = n; while (i &gt; 1) { i /= 2; } } // repeatedly looping in our while and cutting n by 2 until n is not greater than 1;</p></li>
</ul>
<h1 id="linear"><strong>Linear</strong></h1>
<ul>
<li><p>Will access each item of the input ‘once’.</p>
<p>function linear(n) { for (let i = 0; i &lt;= n; i++) { console.log(i); } } // for loop increases based on size of n;</p>
<p>function linear(array) { for (let i = 0; i &lt; array.length; i++) { console.log(i); } } // same thing as above except increases with array length;</p>
<p>function linear(n) { if (n === 1) return; linear(n - 1); } // we use recursion here but as you can see the amt of recursive calls still scale linearly based on n input size. (if we were calling linear(n / 2) then this time complexity would be O(log(n)));</p>
<p>const printAll = (li) =&gt; { li.forEach((ele) =&gt; { console.log(ele); }); };</p>
<p>const find = (li, value) =&gt; { for (let i = 0; i &lt; li.length; i++) { if (li[i] === value) return true; } return false; };</p>
<p>const printAlot = (li) =&gt; { for (let i = 0; i &lt; li.length; i++) { for (let j = 0; j &lt; 10; j++) { console.log(li[j]); } } }; // We have a double for loop but our inner is a fixed loop, therefore not making it polynomial time.</p>
<p>function actuallyLin(n) { if (n &lt;= 1) return; for (let i = 0; i &lt;= n; i++) { console.log(i); } actuallyLin(n / 2); }</p></li>
</ul>
<h1 id="linear-logarithmic-linearithmetic-quasilinear"><strong>Linear Logarithmic( Linearithmetic &amp; Quasilinear )</strong></h1>
<ul>
<li>Sees features from both linear and logarithmic classes.</li>
<li><p>Will use both recursion and iteration.</p>
<p>function logLinear(n) { if (n &lt;= 1) return; for (let i = 0; i &lt;= n; i++) { console.log(i); } logLinear(n / 4); logLinear(n / 4); logLinear(n / 4); // logLinear(n / 2); } // runtime is log linear // T(nlog(n)); Merge sort;</p>
<p>const splitButIterate = (li) =&gt; { if (li.length &lt; 2) return li; const midIdx = li.length / 2; splitButIterate(li.slice(0, midIdx)); splitButIterate(li.slice(midIdx));</p>
<p>li.forEach((ele) =&gt; console.log(ele)); };</p></li>
</ul>
<h1 id="polynomial"><strong>Polynomial</strong></h1>
<ul>
<li><p>C is a fixed constant.</p>
<p>function quadratic(n) { for (let i = 0; i &lt;= n; i++) { for (let j = 0; j &lt;= n; j++) { console.log(i, j); } } } // double for loops, loops n twice! O(n^2);</p>
<p>function cubic(n) { for (let i = 1; i &lt;= n; i++) { for (let j = 1; j &lt;= n; j++) { for (let k = 1; k &lt;= n; k++) {} } } } // triple for loops, loops n three times! O(n^3);</p></li>
</ul>
<h1 id="exponential"><strong>Exponential</strong></h1>
<ul>
<li>C constant is now the number of recursive calls made in each stack frame.</li>
<li>C is the # of splits in your tree diagram.</li>
<li><p>Exponential is the inverse of log.</p>
<p>function expo(n) { if (n === 1) return; exponential(n - 1); exponential(n - 1); }</p>
<p>function expo(n) { if (n === 1) return; exponential(n - 1); exponential(n - 1); exponential(n - 1); }</p></li>
</ul>
<h1 id="factorial"><strong>Factorial</strong></h1>
<ul>
<li><p>O(n!)</p>
<p>function factorial(n) { if (n === 1) return n; for (let i = 0; i &lt; n; i++) { factorial(n - 1); } }</p></li>
</ul>
<hr />
</body>
</html>
