<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Notes</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="notes"><strong>Notes</strong></h1>
<h2 id="big-o"><strong>Big O</strong></h2>
<pre><code>function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}</code></pre>
<blockquote>
<p>Recursive Factorial <img src="https://cdn.discordapp.com/attachments/222504021074640898/747564564735983769/image0.jpg" alt="fac" /> Visual Whiteboard of Rec Fac.</p>
</blockquote>
<pre><code>function fibonacci(n) {
  if (n === 1 || n === 2) return 1;
  return fib(n - 1) + fib(n - 2);
}</code></pre>
<blockquote>
<p>Recursive Fibonacci <img src="https://cdn.discordapp.com/attachments/222504021074640898/747565593909133432/image0.jpg" alt="fib" /> Visual Whiteboard of Rec Fib.</p>
</blockquote>
<hr />
<h2 id="big-o-notation"><strong>Big O Notation</strong></h2>
<ul>
<li><p>Big O helps gives us a precise vocabulary to talk about how our code performs.</p>
<ul>
<li>Useful for discussing trade-offs between different approaches.</li>
<li>Helps us debug things easier.</li>
<li>It also comes up a lot in interviews!</li>
</ul></li>
<li><p>An Example: Comparing two functions that calculate the sum of all numbers from 1 up to n.</p>
<p>function addUpTo(n) { let total = 0; for (let i = 0; i &lt;= n; i++) { total += i; } return total; }</p></li>
</ul>
<blockquote>
<p>Number of operations will grow with n. Would be O(n) or Linear Time.</p>
</blockquote>
<pre><code>function addUpTo(n) {
  return (n * (n + 1)) / 2;
}</code></pre>
<blockquote>
<p>Has three simple operations: 1 Multiplication 1 Addition 1 Division. (Regardless of n) Would be O(1) or Constant Time.</p>
</blockquote>
<ul>
<li><p>First we need to consider what makes one implementation better than the other?</p>
<ul>
<li>Faster? (Time Complexity);</li>
<li>Less Memory Intensive (Space Complexity);</li>
<li>More Readable</li>
</ul></li>
<li><p>How can we measure speed?</p>
<ul>
<li>Timers? (Doesn’t work well - not reliable or precise)</li>
<li>Instead we should count the number of simple operations.</li>
</ul></li>
<li>Big O Notation is a way to formalize fuzzy counting.</li>
<li>An algorithm is O(f(n)) if the number of simple operations the computer has to do is eventually less than a constant f(n) times, as n increases.
<ul>
<li>f(n) = n (Linear)</li>
<li>f(n) = n^2 (Quadratic)</li>
<li>f(n) = 1 (Constant)</li>
<li>f(n) could be anything!</li>
</ul>
<p>function countUpAndDown(n) { console.log(‘going up!’); for (let i = 0; i &lt; n; i++) { console.log(i); } console.log(‘at the top, going down!’); for (let j = n - 1; j &gt;=0; j–) { console.log(j); } console.log(’Back down, bye!); }</p></li>
</ul>
<blockquote>
<p>Both loops are O(n) but since we just want the big picture, this entire function would be O(n);</p>
</blockquote>
<pre><code>function printAllPairs(n) {
  for (var i = 0; i &lt; n; i++) {
    for (var j = 0; j &lt; n; j++) {
      console.log(i, j);
    }
  }
}</code></pre>
<blockquote>
<p>Nested loops are never a good thing when trying to write fast code. O(n^2) or Quadratic Time.</p>
</blockquote>
<ul>
<li><p>Constants don’t matter in big O &amp; Smaller Terms don’t matter</p>
<ul>
<li>O(2n) is just O(n) Linear</li>
<li>O(500) is just O(1) Constnat</li>
<li>O(13n^2) is just O(n^2) Quadratic</li>
<li>O(n + 10) is just O(n) Linear</li>
<li>O(1000n + 50) is just O(n) Linear</li>
<li>O(n^2 + 5n + 8) is just O(n^2) Quadratic</li>
</ul></li>
<li><p><strong><code>Big O Shorthands</code></strong></p>
<ul>
<li>Arithmetic Operations are Constant</li>
<li>Variable assignment is constant</li>
<li>Accessing elements in an array (by index) or by object (by key) is constant.</li>
<li>In a loop, the complexity is the length of the loop times the complexity of whatever is inside of the loop.</li>
</ul></li>
<li><p>Additional Examples</p>
<p>function logAtLeast5(n) { for (var i = 1; i &lt;= Math.max(5, n); i++) { console.log(i); } }</p></li>
</ul>
<blockquote>
<p>O(n) Linear Time</p>
</blockquote>
<pre><code>function logAtMost5(n) {
  for (var i = 1; i &lt;= Math.min(5, n); i++) {
    console.log(i);
  }
}</code></pre>
<blockquote>
<p>O(1) Constant Time.</p>
</blockquote>
<hr />
<h2 id="a-guide-to-big-o-notation"><strong>A Guide to Big-O Notation</strong></h2>
<p><strong>Curating Complexity: A Guide to Big-O Notation</strong></p>
<ul>
<li><p>Why is looking at runtime not a reliable method of calculating time complexity?</p>
<ul>
<li>Not all computers are made equal( some may be stronger and therefore boost our runtime speed )</li>
<li>How many background processes ran concurrently with our program that was being tested?</li>
<li>We also need to ask if our code remains performant if we increase the size of the input.</li>
</ul></li>
<li><p>The real question we need to answering is: <strong><code>How does our performance scale?</code></strong>.</p></li>
</ul>
<p><strong>Big O Notation</strong></p>
<ul>
<li>Big O Notation is a tool for describing the efficiency of algorithms with respect to the size of the input arguments.</li>
<li>Since we use mathematical functions in Big-O, there are a few big picture ideas that we’ll want to keep in mind:
<ul>
<li>The function should be defined by the size of the input.</li>
<li><strong><code>Smaller</code></strong> Big O is better (lower time complexity)</li>
<li>Big O is used to describe the worst case scenario.</li>
<li>Big O is simplified to show only its most dominant mathematical term.</li>
</ul></li>
</ul>
<p><strong>Simplifying Math Terms</strong></p>
<ul>
<li><p>We can use the following rules to simplify the our Big O functions:</p>
<ul>
<li><strong><code>Simplify Products</code></strong> : If the function is a product of many terms, we drop the terms that don’t depend on n.</li>
<li><strong><code>Simplify Sums</code></strong> : If the function is a sum of many terms, we drop the non-dominant terms.</li>
</ul></li>
<li><strong><code>n</code></strong> : size of the input</li>
<li><strong><code>T(f)</code></strong> : unsimplified math function</li>
<li><p><strong><code>O(f)</code></strong> : simplified math function.</p></li>
</ul>
<p><strong><code>Simplifying a Product</code></strong> | Unsimplified | Big-O Simplified | | ———— | —————- | | T(5 _ n^2) | O(n^2) Quadratic | | T(100000 _ n) | O(n) Linear | | T( n / 12) | O (n) Linear | | T( 42 _ n _ log(n)) | O(nlog(n)) Log Linear | | T(12) | O(1) Constant |</p>
<p><strong><code>Simplifying a Sum</code></strong> | Unsimplified | Big-O Simplified | | ———— | —————- | | T( n3 + n2 + n ) | O(n^3) | | T( log(n) + 2n )| O(2^n) Exponential | | T( n + log(n) ) | O(n) Linear | | T( n! + 10n ) | O(n!) Polynomial |</p>
<p><strong><code>Putting it all together</code></strong></p>
<table>
<thead>
<tr class="header">
<th>
Unsimplified
</th>
<th>
Big-O Simplified
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
T( 5n2 + 99n )
</td>
<td>
O(n^2) Quadratic
</td>
</tr>
<tr class="even">
<td>
T( 2n + nlog(n) )
</td>
<td>
O(nlog(n)) Log Linear
</td>
</tr>
<tr class="odd">
<td>
T( 2n + 5n1000)
</td>
<td>
O(2^n) Exponential
</td>
</tr>
</tbody>
</table>
<ul>
<li>First we apply the product rule to drop all constants.</li>
<li>Then we apply the sum rule to select the single most dominant term.</li>
</ul>
<hr />
<h2 id="complexity-classes"><strong>Complexity Classes</strong></h2>
<p><strong>Common Complexity Classes</strong></p>
<blockquote>
<p>There are 7 major classes in Time Complexity</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>
Big O
</th>
<th>
Complexity Class Name
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
O(1)
</td>
<td>
Constant
</td>
</tr>
<tr class="even">
<td>
O(log(n))
</td>
<td>
Logarithmic
</td>
</tr>
<tr class="odd">
<td>
O(n)
</td>
<td>
Linear
</td>
</tr>
<tr class="even">
<td>
O(nlog(n))
</td>
<td>
Loglinear, Linearithmetic, Quasilinear
</td>
</tr>
<tr class="odd">
<td>
O(nc) - O(n2), O(n3), etc.
</td>
<td>
Polynomial
</td>
</tr>
<tr class="even">
<td>
O(cn) - O(2n), O(3n), etc.
</td>
<td>
Exponential
</td>
</tr>
<tr class="odd">
<td>
O(n!)
</td>
<td>
Factorial
</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong><code>O(1) Constant</code></strong></p>
<ul>
<li><p>The algorithm takes roughly the same number of steps for any input size.</p>
<p>// O(1) function constant1(n) { return n * 2 + 1; }</p>
<p>// O(1) function constant2(n) { for (let i = 1; i &lt;= 100; i++) { console.log(i); } }</p></li>
</ul></li>
<li><p><strong><code>O(log(n)) Logarithmic</code></strong></p>
<ul>
<li><p>In most cases our hidden base of Logarithmic time is 2, log complexity algo’s will typically display ‘halving’ the size of the input (like binary search!)</p>
<p>// O(log(n)) function logarithmic1(n) { if (n &lt;= 1) return; logarithmic1(n / 2); }</p>
<p>// O(log(n)) function logarithmic2(n) { let i = n; while (i &gt; 1) { i /= 2; } }</p></li>
</ul></li>
<li><p><strong><code>O(n) Linear</code></strong></p>
<ul>
<li><p>Linear algo’s will access each item of the input “once”.</p>
<p>// O(n) function linear1(n) { for (let i = 1; i &lt;= n; i++) { console.log(i); } }</p>
<p>// O(n), where n is the length of the array function linear2(array) { for (let i = 0; i &lt; array.length; i++) { console.log(i); } }</p>
<p>// O(n) function linear3(n) { if (n === 1) return; linear3(n - 1); }</p></li>
</ul></li>
<li><strong><code>O(nlog(n)) Log Linear Time</code></strong>
<ul>
<li>Combination of linear and logarithmic behavior, we will see features from both classes.</li>
<li>Algo’s that are log-linear will use both recursion AND iteration.</li>
</ul>
<p>// O(n * log(n)) function loglinear(n) { if (n &lt;= 1) return;</p>
<p>for (let i = 1; i &lt;= n; i++) { console.log(i); }</p>
<p>loglinear(n / 2); loglinear(n / 2); }</p></li>
<li><strong><code>O(nc) Polynomial</code></strong>
<ul>
<li>C is a fixed constant.</li>
</ul>
<p>// O(n^2) function quadratic(n) { for (let i = 1; i &lt;= n; i++) { for (let j = 1; j &lt;= n; j++) {} } }</p>
<p>// O(n^3) function cubic(n) { for (let i = 1; i &lt;= n; i++) { for (let j = 1; j &lt;= n; j++) { for (let k = 1; k &lt;= n; k++) {} } } }</p></li>
<li><p>Example of Quadratic and Cubic runtime.</p></li>
<li><strong><code>O(c^n) Exponential</code></strong>
<ul>
<li>C is now the number of recursive calls made in each stack frame.</li>
<li>Algo’s with exponential time are VERY SLOW.</li>
</ul>
<p>// O(2^n) function exponential2n(n) { if (n === 1) return; exponential_2n(n - 1); exponential_2n(n - 1); }</p>
<p>// O(3^n) function exponential3n(n) { if (n === 0) return; exponential_3n(n - 1); exponential_3n(n - 1); exponential_3n(n - 1); }</p></li>
<li><strong><code>O(n!) Factorial</code></strong>
<ul>
<li>The largest/ worst complexity (minus DTIME which is n^n);</li>
</ul></li>
</ul>
<hr />
<h2 id="memoization"><strong>Memoization</strong></h2>
<ul>
<li><strong>Memoization</strong> : a design pattern used to reduce the overall number of calculations that can occur in algorithms that use recursive strategies to solve.
<ul>
<li>MZ stores the results of the sub-problems in some other data structure, so that we can avoid duplicate calculations and only ‘solve’ each problem once.</li>
<li>Two features that comprise memoization:
<ul>
<li><ol type="1">
<li>FUNCTION MUST BE RECURSIVE.</li>
</ol></li>
<li><ol type="1">
<li>Our additional DS is usually an object (we refer to it as our memo!)</li>
</ol></li>
</ul></li>
</ul></li>
</ul>
<p><strong>Memoizing Factorial</strong></p>
<pre><code>let memo = {};

function factorial(n) {
  // if this function has calculated factorial(n) previously,
  // fetch the stored result in memo
  if (n in memo) return memo[n];
  if (n === 1) return 1;

  // otherwise, it havs not calculated factorial(n) previously,
  // so calculate it now, but store the result in case it is
  // needed again in the future
  memo[n] = n * factorial(n - 1);
  return memo[n];
}

factorial(6); // =&gt; 720, requires 6 calls
factorial(6); // =&gt; 720, requires 1 call
factorial(5); // =&gt; 120, requires 1 call
factorial(7); // =&gt; 5040, requires 2 calls

memo; // =&gt; { &#39;2&#39;: 2, &#39;3&#39;: 6, &#39;4&#39;: 24, &#39;5&#39;: 120, &#39;6&#39;: 720, &#39;7&#39;: 5040 }</code></pre>
<ul>
<li>Our memo object is <em>mapping</em> out our arguments of factorial to it’s return value.
<ul>
<li>Keep in mind we didn’t improve the speed of our algo.</li>
</ul></li>
</ul>
<p><strong>Memoizing Fibonacci</strong> <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/memoization/images/fib_memoized.png" alt="memofib" /></p>
<ul>
<li>Our time complexity for fibonacci goes from O(2^n) to O(n) after applying memoization.</li>
</ul>
<p><strong>The Memoization Formula</strong></p>
<blockquote>
<p>Rules</p>
</blockquote>
<ol type="1">
<li>Write the unoptimized brute force recursion (make sure it works);</li>
<li>Add memo object as an additional arugmnt .</li>
<li>Add a base case condition that returns the stored value if the function’s argument is in the memo.</li>
<li>Before returning the result of the recursive case, store it in the memo as a value and make the function’s argument it’s key.</li>
</ol>
<blockquote>
<p>Things to remember</p>
</blockquote>
<ol type="1">
<li>When solving DP problems with Memoization, it is helpful to draw out the visual tree first.</li>
<li>When you notice duplicate sub-tree’s that means we can memoize.</li>
</ol>
<hr />
<h2 id="section">**</h2>
<pre><code>function fastFib(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n === 1 || n === 2) return 1;

  memo[n] = fastFib(n - 1, memo) + fastFib(n - 2, memo);
  return memo[n];
}

fastFib(6); // =&gt; 8
fastFib(50); // =&gt; 12586269025</code></pre>
<hr />
<h2 id="tabulation"><strong>Tabulation</strong></h2>
<ul>
<li><strong>Tabulation Strategy</strong>
<ul>
<li>Use When:
<ul>
<li>The function is iterative and not recursive.</li>
<li>The accompanying DS is usually an array.</li>
</ul></li>
</ul>
<p>function fib(n) { let mostRecentCalcs = [0, 1];</p>
<p>if (n === 0) return mostRecentCalcs[0];</p>
<p>for (let i = 2; i &lt;= n; i++) { const [secondLast, last] = mostRecentCalcs; mostRecentCalcs = [last, secondLast + last]; }</p>
<p>return mostRecentCalcs[1]; }</p></li>
<li>Steps for tabulation
<ul>
<li>Create a table array based off the size of the input.</li>
<li>Initialize some values in the table to ‘answer’ the trivially small subproblem.</li>
<li>Iterate through the array and fill in the remaining entries.</li>
<li>Your final answer is usually the last entry in the table.</li>
</ul></li>
</ul>
<hr />
<h1 id="class-examples"><strong>Class Examples</strong></h1>
<h2 id="example-of-linear-search"><strong>Example of Linear Search</strong></h2>
<pre><code>function search(array, term) {
  for (let i = 0; i &lt; array.length; i++) {
    if (array[i] === term) {
      return i;
    }
  }
  return -1;
}</code></pre>
<ul>
<li>Worst Case Scenario: The term does not even exist in the array.</li>
<li>Meaning: If it doesn’t exist then our for loop would run until the end therefore making our time complexity O(n).</li>
</ul>
<h2 id="example-of-binary-search"><strong>Example of Binary Search</strong></h2>
<pre><code>function binarySearch(arr, x, start, end) {
  if (start &gt; end) return false;

  let mid = Math.floor((start + end) / 2);
  if (arr[mid] === x) return true;

  if (arr[mid] &gt; x) {
    return binarySearch(arr, x, start, mid - 1);
  } else {
    return binarySearch(arr, x, mid + 1, end);
  }
}</code></pre>
<ul>
<li>Must be conducted on a sorted array.</li>
<li>Binary search is logarithmic time, not exponential b/c n is cut down by two, not growing.</li>
<li>Binary Search is part of Divide and Conquer.</li>
</ul>
<h2 id="example-of-merge-sort"><strong>Example of Merge Sort</strong></h2>
<pre><code>function merge(leftArray, rightArray) {
  const sorted = [];
  while (letArray.length &gt; 0 &amp;&amp; rightArray.length &gt; 0) {
    const leftItem = leftArray[0];
    const rightItem = rightArray[0];

    if (leftItem &gt; rightItem) {
      sorted.push(rightItem);
      rightArray.shift();
    } else {
      sorted.push(leftItem);
      leftArray.shift();
    }
  }

  while (leftArray.length !== 0) {
    const value = leftArray.shift();
    sorted.push(value);
  }

  while (rightArray.length !== 0) {
    const value = rightArray.shift();
    sorted.push(value);
  }

  return sorted;
}

function mergeSort(array) {
  const length = array.length;
  if (length === 1) {
    return array;
  }

  const middleIndex = Math.ceil(length / 2);
  const leftArray = array.slice(0, middleIndex);
  const rightArray = array.slice(middleIndex, length);

  leftArray = mergeSort(leftArray);
  rightArray = mergeSort(rightArray);

  return merge(leftArray, rightArray);
}</code></pre>
<hr />
<h2 id="example-of-bubble-sort"><strong>Example of Bubble Sort</strong></h2>
<pre><code>function bubbleSort(items) {
  var length = items.length;
  for (var i = 0; i &lt; length; i++) {
    for (var j = 0; j &lt; length - i - 1; j++) {
      if (items[j] &gt; items[j + 1]) {
        var tmp = items[j];
        items[j] = items[j + 1];
        items[j + 1] = tmp;
      }
    }
  }
}</code></pre>
<ul>
<li>Worst Case &amp; Best Case are always the same because it makes nested loops.</li>
<li>Double for loops are polynomial time complexity or more specifically in this case Quadratic big O O(n^2);</li>
</ul>
</body>
</html>
