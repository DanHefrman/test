<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>w7_learning_objectives</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="week-7-learning-objectives">Week 7 Learning Objectives</h1>
<h2 id="github-profile-and-projects-objectives-these-are-not-going-to-be-on-the-assessment">GitHub Profile and Projects Objectives (<em>THESE ARE NOT GOING TO BE ON THE ASSESSMENT</em>)</h2>
<h3 id="github-is-a-powerful-platform-that-hiring-managers-and-other-developers-can-use-to-see-how-you-create-software.">GitHub is a powerful platform that hiring managers and other developers can use to see how you create software.</h3>
<ul>
<li>Participate in the social aspects of GitHub by starring repositories, following other developers, and reviewing your followers</li>
<li>Use Markdown to write code snippets in your README files.</li>
<li>You will craft your GitHub profile and contribute throughout the course by keeping your “gardens green”</li>
<li>You will be able to identify the basics of a good Wiki entries for proposals and minimum viable products</li>
<li>You will be able to identify the basics of a good project README that includes technologies at the top, images, descriptions and code snippets</li>
</ul>
<h2 id="big-o-learning-objectives">Big O Learning Objectives</h2>
<ul>
<li>Big O notation lets us express the time complexity of an algorithm in terms of magnitude of the input, based on the number of operations</li>
<li>from Colt Steel: ‘an algorithm is <code>O(f(n))</code> if the number of simple operations the computer has to do is eventually less than a constant times <code>f(n)</code>, as <code>n</code> increases’</li>
<li>big O should reflect performance with respect to input size and nothing else, so
<ul>
<li>simplify products by dropping the terms that don’t depend on the size of the input</li>
<li>simplify sums by keeping only terms with the largest growth rate ### Order the common complexity classes according to their growth rate</li>
</ul></li>
</ul>
<ol type="1">
<li><p>constant time: <code>O(1)</code></p>
<p>// constant time example // this function has a constant number of operations, // regardless of the size of n // even if there were a million operations, it would still be // linear time as long as the number of operations stayed the // same for any n function constantTime(n) { n += 5; n -= 2; return n; }</p></li>
<li><p>log: <code>O(log(n))</code></p>
<p>// log time example // this iterative function is log time because the size of our // iterative step doubles on each loop. function logTime(n) { let i = 1; let arr = []; while (i &lt; n) { arr.push(i); i *= 2; } } // in the recursive example, with each call to our function, // the size of the input is halved function logTimeRecursive (n) { // base case if (n &lt;= 1) return; //recursive step logTimeRecursive(n/2) }</p></li>
<li><p>linear: <code>O(n)</code></p>
<p>// for linear functions (both recursive and iterative) // the step size is constant—usually we use a step size // of 1, but any constant step size will be linear time function linearTime (n) { for (let i = 0; i &lt; n; i +=5) { console.log(<code>${i} cats</code>); } }</p>
<p>function linearTimeRecursive (n) { if (n &lt;= 1) return; console.log(<code>${n} cats</code>); linearTimeRecursive(n-5); }</p></li>
<li><p>loglinear: <code>O(n*log(n))</code></p>
<p>// this is usually a combination of linear and log time operations // e.g. if you nest a linear-time operation in a log-time loop function logTime(n) { let i = 1; let arr = []; while (i &lt; n) { arr.push(i); i *= 2; for (let j = 0; j &lt; n; j +=5) { console.log(<code>${j} cats</code>); } } }</p>
<p>// or recursively, if you have a log time helper function // in a linear-time recursive function function logLinearRecursion(n) { helperLogTime (x) { if (x === 1) return; console.log(x); helperLogTime(x/2) } helperLogTime(n); logLinearRecursive(n-1); }</p></li>
<li><p>polynomial: <code>O(n^C)</code></p>
<p>// the classic example would be nested for loops function polynomialTime (n) { for (let i = 0; i &lt; n; i ++) { for (let j = 0; j &lt; n; j ++) { console.log(<code>${i}:${j}</code>) } } } // with recursion, this could involve nested recursive function // calls where the step size is constant // importantly, the inner function only calls itself once // honestly i don’t think this pattern is especially common function polynomialRecursion(n) { if (n === 0) return; function helper (x) { if (x === 0) return; console.log(x) helper(x-1); } helper(n); polynomialRecursion(n-1); }</p></li>
<li><p>exponential: <code>O(C^n)</code></p>
<p>// still trying to come up with an iterative // exponential time function</p>
<p>// recursive version would be when a recursive function // invokes itself multiple times // fibonacci is an example of this function expRecursive (n) { if (n === 0) return ‘done!’; expRecursive(n-1); expRecursive(n-1);</p>
<p>}</p></li>
<li><p>factorial: <code>O(n!)</code></p>
<p>// with factorial, the number of times the function // branches (invokes itself) would also depend on n // in a simple case, you could do that with a for loop // can’t think of an iterative example here either</p>
<p>// a good example of an O(n!) algorithm would be // getting every possible subset of any length from // a set of items function factorial (n) { if (n === 1) return;</p>
<pre><code>for (let i = 1; i &lt;= n; i ++) {
    factorialTime(n-1);
}</code></pre>
<p>}</p></li>
</ol>
<h3 id="identify-the-complexity-classes-of-common-sort-methods">Identify the complexity classes of common sort methods</h3>
<ul>
<li>bubble sort: <code>O(n^2)</code> time complexity, <code>O(1)</code> space complexity</li>
<li>selection sort: <code>O(n^2)</code> time complexity,, <code>O(1)</code> space complexity</li>
<li>insertion sort: <code>O(n^2)</code> time complexity,, <code>O(1)</code> space complexity</li>
<li>merge sort: <code>O(n*log(n))</code> time complexity, <code>O(n)</code> space complexity (or <code>O(n*log(n))</code> if we do it by keeping track of indices rather than allocating a new array each time)</li>
<li>quick sort: <code>O(n*log(n))</code> time complexity on average, <code>O(n</code><sup><code>2</code></sup><code>)</code> worst case. however, worst case is rare. space complexity <code>O(n)</code> naively, but can be tweaked to be <code>O(log(n))</code></li>
<li>binary search: <code>O(n*log(n))</code> (requires a sorted list) ### Identify complexity classes of code</li>
</ul>
<h2 id="memoization-and-tabulation-learning-objectives">Memoization And Tabulation Learning Objectives</h2>
<h3 id="apply-memoization-to-recursive-problems-to-make-them-less-than-polynomial-time.">Apply memoization to recursive problems to make them less than polynomial time.</h3>
<ul>
<li>memoization allows us to trade time complexity for space complexity, for certain recursive problems that have “overlapping subproblem structure”</li>
<li>to memoize
<ul>
<li>write non-memo version</li>
<li>add a memo object as additional arg</li>
<li>add a base case for when the value is stored in the memo</li>
<li>before you return, store the value in the memo ```javascript // original function function fib(n) { if (n === 1 || n === 2) return 1; return fib(n - 1) + fib(n - 2); } // memoization let memo = {} function fib(n) { if (n in memo) return memo[n]; if (n === 1 || n === 2) return 1; memo[n] = fib(n - 1) + fib(n - 2); return memo[n]; }</li>
</ul></li>
</ul>
<p>``` ### Apply tabulation to iterative problems to make them less than polynomial time. - tabulation also allows one to trade time complexity for space complexity, but with an iterative strategy (typically useful for same set of problems, though) - to tabulate - create a table based on size of input - initalize values for the trivially small problems - iterate through remaining entries, using previous calculations - final answer is last entry in table</p>
<pre><code>function tabulatedFib(n) {
  // create a blank array with n reserved spots
  let table = new Array(n);

  // seed the first two values
  table[0] = 0;
  table[1] = 1;

  // complete the table by moving from left to right,
  // following the fibonacci pattern
  for (let i = 2; i &lt;= n; i += 1) {
    table[i] = table[i - 1] + table[i - 2];
  }

  return table[n];
}

// version with O(1) space
function fib(n) {
  let mostRecentCalcs = [0, 1];

  if (n === 0) return mostRecentCalcs[0];

  for (let i = 2; i &lt;= n; i++) {
    const [ secondLast, last ] = mostRecentCalcs;
    mostRecentCalcs = [ last, secondLast + last ];
  }

  return mostRecentCalcs[1];
}</code></pre>
<h2 id="sorting-algorithms">Sorting Algorithms</h2>
<h3 id="explain-the-complexity-of-and-write-a-function-that-performs-bubble-sort-on-an-array-of-numbers.">Explain the complexity of and write a function that performs bubble sort on an array of numbers.</h3>
<ul>
<li>bubble sort is a very simple sorting algorithm with typically poor performance.</li>
<li><p>bubble sort takes quadratic time(<code>O(n</code><sup><code>2</code></sup><code>)</code>) both on average and in the worst case</p>
<p>function bubble(array) { let noSwaps = false; while (noSwaps === false) { noSwaps = true; for (let i = 1; i &lt; array.length; i ++) { if (array[i - 1] &gt; array[i]) { let swap = arr[j]; arr[j] = arr[j+1]; arr[j+1] = swap; noSwaps = false; } } } return array; }</p></li>
</ul>
<h3 id="explain-the-complexity-of-and-write-a-function-that-performs-selection-sort-on-an-array-of-numbers.">Explain the complexity of and write a function that performs selection sort on an array of numbers.</h3>
<pre><code>function selection(list) {
    for(let i = 0; i &lt; list.length; i++) {
        let min = i;
        for(let j = i + 1; j &lt; list.length; j++) {
            if (list[j] &lt; list[min]) {
                min = j;
            }
        }
        if (min !== i) {
            let swap = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = swap;
        }
    }
    return list;
}</code></pre>
<h3 id="explain-the-complexity-of-and-write-a-function-that-performs-insertion-sort-on-an-array-of-numbers.">Explain the complexity of and write a function that performs insertion sort on an array of numbers.</h3>
<pre><code>function insertion(list) {
    for (let i = 1; i &lt; list.length; i ++) {
        let valueToInsert = list[i];
        let holePosition = i;
        while (holePosition &gt; 0 &amp;&amp; list[holePosition-1] &gt; valueToInsert) {
            list[holePosition] = list[holePosition-1];
            holePosition = holePosition -1;
        }
        list[holePosition] = valueToInsert;
  }
}</code></pre>
<h3 id="explain-the-complexity-of-and-write-a-function-that-performs-merge-sort-on-an-array-of-numbers.">Explain the complexity of and write a function that performs merge sort on an array of numbers.</h3>
<pre><code>function mergeTwo(array1, array2) {
  let result = [];
  while (array1.length &gt; 0 &amp;&amp; array2.length &gt; 0) {
    if ( array1[0] &gt; array2[0] ) {
      result.push(array2.shift());
    } else {
      result.push(array1.shift())
    }
  }

  while (array1.length &gt; 0) result.push(array1.shift());
  while (array2.length &gt; 0) result.push(array2.shift());

  return result;
}

function merge(array) {
  if ( array.length &lt;= 1 ) return array;
  let l1 = array.slice(0, Math.floor(array.length / 2));
  let l2 = array.slice(Math.floor(array.length / 2));

  l1 = merge( l1 );
  l2 = merge( l2 );

  return mergeTwo( l1, l2 );
}</code></pre>
<h3 id="explain-the-complexity-of-and-write-a-function-that-performs-quick-sort-on-an-array-of-numbers.">Explain the complexity of and write a function that performs quick sort on an array of numbers.</h3>
<pre><code>function quickSort(array) {
  if(array.length &lt;= 1) return array;
  let pivot = array.shift();
  let left = array.filter(el =&gt; el &lt; pivot);
  let right = array.filter(el =&gt; el &gt;= pivot);

  let leftSorted = quickSort(left);
  let rightSorted = quickSort(right);

  return [...leftSorted, pivot, ...rightSorted];
}</code></pre>
<h3 id="explain-the-complexity-of-and-write-a-function-that-performs-a-binary-search-on-a-sorted-array-of-numbers.">Explain the complexity of and write a function that performs a binary search on a sorted array of numbers.</h3>
<pre><code>function binarySearch(list, target) {
  if (list.length === 0) return false;
  let slicePoint = Math.floor((list.length) / 2);
  let leftHalf = list.slice(0, slicePoint);
  let rightHalf = list.slice(slicePoint+1);

  if (target &lt; list[slicePoint]) {
    return binarySearch(leftHalf, target);
  } else if (target &gt; list[slicePoint]) {
    return binarySearch(rightHalf, target);
  } else {
    return true;
  }

}</code></pre>
<h2 id="lists-stacks-and-queues">Lists, Stacks, and Queues</h2>
<ul>
<li>Abstract data types have structure, properties, and behavior that exist without respect to the details of the language or implementation</li>
<li>Different ADTs have different qualities that lend themselves to solving different types of problems</li>
<li>Examples include
<ul>
<li>Sets: collection with no repeated elements, can add, remove, or check whether an element is present</li>
<li>Maps (i.e. dictionaries): specific input yields specific output. can get the value associated with a given key, can set a value for a key, can delete the key value pair given a key</li>
<li>also lists, stacks, queues ### Explain and implement a List.</li>
</ul></li>
<li>every element can be accessed</li>
<li>size can change when elements are added and removed</li>
<li>operations:
<ul>
<li>insert at: add an element at a specific index (this will shift the index of subsequent elements)</li>
<li>remove at index: removes the element at a specific index (this will shift the index of subsequent elements)</li>
<li>get at index: returns the value of the element at a given index</li>
</ul></li>
<li>arrays and linked lists are both implementations of lists, but they have different advantages and disadvantages
<ul>
<li>time complexity</li>
</ul>
<table>
<thead>
<tr class="header">
<th>
Operation
</th>
<th>
Array
</th>
<th>
Linked List
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
get()
</td>
<td>
<code>O(1)</code>
</td>
<td>
<code>O(n)</code>
</td>
</tr>
<tr class="even">
<td>
insert()
</td>
<td>
<code>O(n)</code>
</td>
<td>
<code>O(1)</code>
</td>
</tr>
<tr class="odd">
<td>
remove()
</td>
<td>
<code>O(n)</code>
</td>
<td>
<code>O(1)</code>
</td>
</tr>
</tbody>
</table>
```javascript // example: linked list</li>
</ul>
<p>// properties // head: the first node // tail: the last node // length: number of nodes</p>
<p>// methods: // addToTail // addToHead // insertAt // removeTail // removeHead // removeFrom // contains // get // set // size</p>
<p>// linked lists consist of nodes // nodes have</p>
<p>// properties: // value: the piece of data stored at that node // next: a pointer to the next node in the list // (for doubly linked lists only) previous: a pointer to the previous node in the list // Nodes don’t have methods of their own</p>
<p>class Node { constructor(val) { this.value = val; this.next = null; // doubly linked list only: // this.prev = null; }</p>
<p>}</p>
<p>class LinkedList { constructor() { // when a new linked list is created // head and tail are initialized to null // because there is nothing in the list this.head = null; this.tail = null; this.length = 0; }</p>
<pre><code>// add a new node to the end of the list
addToTail(val) {
    let newTail = new Node(val);
    if(this.tail !== null) {
        this.tail.next = newTail;
    } else {
        this.head = newTail;
    }
    this.tail = newTail;
    this.length++;
    return this;
}

// remove the final node in the list
removeTail() {
    // node before the tail should be new tail
    // nodes pointer should be set to null; no nodes after it
    // if there are no elements to remove, return undefined
    if (this.length === 0) return undefined;
    if (this.length === 1) {
        this.head = null;
        this.tail = null;

    } else {
        let oldTail = this.tail;
        let currentNode = this.head;
        while(currentNode.next !== this.tail) {
            currentNode = currentNode.next;
        }
        this.tail = currentNode;
        currentNode.next = null;
    }
    this.length--;
    return oldTail;

}

// add a new node to the start of the list
addToHead(val) {
    let newHead = new Node(val);
    if (this.head !== null) {
        newHead.next = this.head;
    } else {
        this.tail = newHead;
    }
    this.head = newHead;
    this.length++;
    return this;
}

// remove the node at the start of the list
removeHead() {
    if(this.length === 0) return undefined;
    let oldHead = this.head;
    this.head = this.head.next;
    if(this.length === 1) {
        this.tail = null;
    }
    this.length--;
    return oldHead;
}

// contains: return true if a given value is present in the array
contains(target) {
    if(this.length === 0) return false;
    let currentNode = this.head;
    for(let i = 0; i &lt; this.length; i++) {
        if(currentNode.value === target) {
            return true;
        }
        currentNode = currentNode.next;
    }
    return false;
}

// get: retrieve the node that is currently at a given index
get(index) {
    // if the index does
    if(index &gt; this.length) return null;
    let currentNode = this.head;
    for(let i = 0; i &lt; index; i++) {
        currentNode = currentNode.next;
    }
    return currentNode;
}

// set: change the value of the existing node at
// a given index
set(index, val) {
    // if the node doesn&#39;t exist, return false
    if(index &gt;= this.length) return false;
    // otherwise use get to access the node
    // then update its value
    this.get(index).value = val;
    return true;
}

// insert: add a new node at an index
insert(index, val) {
    // if the index is too high, return false
    if (index &gt;= this.length) return false;
    if (index === 0) {
        // if the index is 0, this is the same as adding to head
        this.addToHead(val);
    } else {
        // create the node to insert
        let newNode = new Node(val);
        // get node before index
        let prevNode = this.get(index-1);
        // get the node after the index
        let nextNode = prevNode.next;
        // set the pointer on the previous node to be the new node
        prevNode.next = newNode;
        // set the pointer on the new node to be the next node
        newNode.next = nextNode;
        // increment length
        this.length++;
    }
    return true;
}

// remove a node from a given index
remove(index) {
    // if the index is out of bounds, you can just return undefined
    if(index &gt;= this.length) return undefined;
    // if the index is 0, it&#39;s the same as removing the head
    if(index === 0) return this.removeHead();

    // otherwise, get the node before the index
    let prevNode = this.get(index - 1);
    let targetNode = prevNode.next;
    // and set its pointer to the node that comes after the node
    // that is being removed
    prevNode.next = targetNode.next;
    this.length--;
    return targetNode;
}

// this method literally just returns the
// length property
size() {
    return this.length;
}</code></pre>
<p>} <code>### Explain and implement a Stack. - Data is always last in, first out (like a literal stack of papers, or plates at a buffet line) - Operations     - push: adds an element to the top of the stack     - pop: removes the top element of the array and returns it     - (optional) peek: gets value at the top element without returning it</code>javascript // stacks could be implemented with an array or a linked list // the interface and behavior remains the same either way, // but the underlying implementation details will change</p>
<p>// for the linked list implementation, the node class is // exactly the same class Node { constructor (val) { this.value = val; this.next = null; } }</p>
<p><code>### Explain and implement a Queue. - Data is always first in, first out (like people waiting in a line, the one that's been waiting the longest goes first) - Operations     - enqueue: adds element to the end of the queue. time complexity: `O(1)`     - dequeue: gets and removes element from the front of the list. time complexity `O(1)`     - (optional) peek: gets the value at the front of the queue without removing it `O(1)`</code>javascript // queues could be implemented with an array or a linked list // the interface and behavior remains the same either way, // but the underlying implementation details will change</p>
<p>// for the linked list implementation, the node class is // exactly the same</p>
<p>```</p>
</body>
</html>
