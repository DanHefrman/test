<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>WEEK7-NOTES</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="notes"><strong>Notes</strong></h1>
<h2 id="improving-your-profile-using-github"><strong>Improving your Profile Using Github</strong></h2>
<ul>
<li>Important sections that represent who you are as a developer:
<ul>
<li>Followers &amp; Following</li>
<li>Stars (likes)</li>
<li>Green Gardens</li>
<li>Photo and Brief Intro</li>
</ul></li>
</ul>
<p><strong>Wikis (Pre-Project)</strong></p>
<ul>
<li><p>Best Practices for Wiki Creation:</p>
<ul>
<li>List of technologies used.</li>
<li>Separate design documents into their own sections.</li>
<li>Write clearly and concisely, grammar is important!</li>
</ul></li>
<li><p><strong><code>MVP</code></strong> : Minimum Viable Product - Outline of your project’s features on your Repo Wiki.</p></li>
<li><em>Example of a MVP</em> :
<ul>
<li>Users are able to log into application</li>
<li>Users are able to create, edit, and delete tweets</li>
<li>Users are able to follow other users and see their tweets</li>
<li>Users are able to like other users tweets</li>
<li>Users are able to comment on other users tweets</li>
</ul></li>
</ul>
<p><strong>README FIles (Post-Project)</strong></p>
<ul>
<li>Consider README’s as first impressions to prospective employers.</li>
<li>Readme’s are done in <strong><code>markdown</code></strong>.</li>
<li>Readme Best Practices:
<ul>
<li>Divide your README into distinct sections</li>
<li>List the technologies used at the top of your README for increased visibility</li>
<li>Include nice pictures or Gifs to show and/or demonstrate how things work</li>
<li>Include code snippets</li>
<li>Provide instructions for how to install project (if applicable)</li>
<li>Include link to the live site</li>
</ul></li>
</ul>
<hr />
<h2 id="github-identity"><strong>Github Identity</strong></h2>
<ul>
<li><strong><code>Github</code></strong> is a community of developers, and is a place to share, build, and discover software (also VC).</li>
</ul>
<h2 id="big-o-notation"><strong>Big O Notation</strong></h2>
<ul>
<li><p>Big O helps gives us a precise vocabulary to talk about how our code performs.</p>
<ul>
<li>Useful for discussing trade-offs between different approaches.</li>
<li>Helps us debug things easier.</li>
<li>It also comes up a lot in interviews!</li>
</ul></li>
<li><p>An Example: Comparing two functions that calculate the sum of all numbers from 1 up to n.</p>
<p>function addUpTo(n) { let total = 0; for (let i = 0; i &lt;= n; i++) { total += i; } return total; }</p></li>
</ul>
<blockquote>
<p>Number of operations will grow with n. Would be O(n) or Linear Time.</p>
</blockquote>
<pre><code>function addUpTo(n) {
  return (n * (n + 1)) / 2;
}</code></pre>
<blockquote>
<p>Has three simple operations: 1 Multiplication 1 Addition 1 Division. (Regardless of n) Would be O(1) or Constant Time.</p>
</blockquote>
<ul>
<li><p>First we need to consider what makes one implementation better than the other?</p>
<ul>
<li>Faster? (Time Complexity);</li>
<li>Less Memory Intensive (Space Complexity);</li>
<li>More Readable</li>
</ul></li>
<li><p>How can we measure speed?</p>
<ul>
<li>Timers? (Doesn’t work well - not reliable or precise)</li>
<li>Instead we should count the number of simple operations.</li>
</ul></li>
<li>Big O Notation is a way to formalize fuzzy counting.</li>
<li>An algorithm is O(f(n)) if the number of simple operations the computer has to do is eventually less than a constant f(n) times, as n increases.
<ul>
<li>f(n) = n (Linear)</li>
<li>f(n) = n^2 (Quadratic)</li>
<li>f(n) = 1 (Constant)</li>
<li>f(n) could be anything!</li>
</ul>
<p>function countUpAndDown(n) { console.log(‘going up!’); for (let i = 0; i &lt; n; i++) { console.log(i); } console.log(‘at the top, going down!’); for (let j = n - 1; j &gt;=0; j–) { console.log(j); } console.log(’Back down, bye!); }</p></li>
</ul>
<blockquote>
<p>Both loops are O(n) but since we just want the big picture, this entire function would be O(n);</p>
</blockquote>
<pre><code>function printAllPairs(n) {
  for (var i = 0; i &lt; n; i++) {
    for (var j = 0; j &lt; n; j++) {
      console.log(i, j);
    }
  }
}</code></pre>
<blockquote>
<p>Nested loops are never a good thing when trying to write fast code. O(n^2) or Quadratic Time.</p>
</blockquote>
<ul>
<li><p>Constants don’t matter in big O &amp; Smaller Terms don’t matter</p>
<ul>
<li>O(2n) is just O(n) Linear</li>
<li>O(500) is just O(1) Constnat</li>
<li>O(13n^2) is just O(n^2) Quadratic</li>
<li>O(n + 10) is just O(n) Linear</li>
<li>O(1000n + 50) is just O(n) Linear</li>
<li>O(n^2 + 5n + 8) is just O(n^2) Quadratic</li>
</ul></li>
<li><p><strong><code>Big O Shorthands</code></strong></p>
<ul>
<li>Arithmetic Operations are Constant</li>
<li>Variable assignment is constant</li>
<li>Accessing elements in an array (by index) or by object (by key) is constant.</li>
<li>In a loop, the complexity is the length of the loop times the complexity of whatever is inside of the loop.</li>
</ul></li>
<li><p>Additional Examples</p>
<p>function logAtLeast5(n) { for (var i = 1; i &lt;= Math.max(5, n); i++) { console.log(i); } }</p></li>
</ul>
<blockquote>
<p>O(n) Linear Time</p>
</blockquote>
<pre><code>function logAtMost5(n) {
  for (var i = 1; i &lt;= Math.min(5, n); i++) {
    console.log(i);
  }
}</code></pre>
<blockquote>
<p>O(1) Constant Time.</p>
</blockquote>
<hr />
<h2 id="a-guide-to-big-o-notation"><strong>A Guide to Big-O Notation</strong></h2>
<p><strong>Curating Complexity: A Guide to Big-O Notation</strong></p>
<ul>
<li><p>Why is looking at runtime not a reliable method of calculating time complexity?</p>
<ul>
<li>Not all computers are made equal( some may be stronger and therefore boost our runtime speed )</li>
<li>How many background processes ran concurrently with our program that was being tested?</li>
<li>We also need to ask if our code remains performant if we increase the size of the input.</li>
</ul></li>
<li><p>The real question we need to answering is: <strong><code>How does our performance scale?</code></strong>.</p></li>
</ul>
<p><strong>Big O Notation</strong></p>
<ul>
<li>Big O Notation is a tool for describing the efficiency of algorithms with respect to the size of the input arguments.</li>
<li>Since we use mathematical functions in Big-O, there are a few big picture ideas that we’ll want to keep in mind:
<ul>
<li>The function should be defined by the size of the input.</li>
<li><strong><code>Smaller</code></strong> Big O is better (lower time complexity)</li>
<li>Big O is used to describe the worst case scenario.</li>
<li>Big O is simplified to show only its most dominant mathematical term.</li>
</ul></li>
</ul>
<p><strong>Simplifying Math Terms</strong></p>
<ul>
<li><p>We can use the following rules to simplify the our Big O functions:</p>
<ul>
<li><strong><code>Simplify Products</code></strong> : If the function is a product of many terms, we drop the terms that don’t depend on n.</li>
<li><strong><code>Simplify Sums</code></strong> : If the function is a sum of many terms, we drop the non-dominant terms.</li>
</ul></li>
<li><strong><code>n</code></strong> : size of the input</li>
<li><strong><code>T(f)</code></strong> : unsimplified math function</li>
<li><p><strong><code>O(f)</code></strong> : simplified math function.</p></li>
</ul>
<p><strong><code>Simplifying a Product</code></strong> | Unsimplified | Big-O Simplified | | ——————- | ——————— | | T(5 _ n^2) | O(n^2) Quadratic | | T(100000 _ n) | O(n) Linear | | T( n / 12) | O (n) Linear | | T( 42 _ n _ log(n)) | O(nlog(n)) Log Linear | | T(12) | O(1) Constant |</p>
<p><strong><code>Simplifying a Sum</code></strong> | Unsimplified | Big-O Simplified | | —————- | —————— | | T( n3 + n2 + n ) | O(n^3) | | T( log(n) + 2n ) | O(2^n) Exponential | | T( n + log(n) ) | O(n) Linear | | T( n! + 10n ) | O(n!) Polynomial |</p>
<p><strong><code>Putting it all together</code></strong></p>
<table>
<thead>
<tr class="header">
<th>
Unsimplified
</th>
<th>
Big-O Simplified
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
T( 5n2 + 99n )
</td>
<td>
O(n^2) Quadratic
</td>
</tr>
<tr class="even">
<td>
T( 2n + nlog(n) )
</td>
<td>
O(nlog(n)) Log Linear
</td>
</tr>
<tr class="odd">
<td>
T( 2n + 5n1000)
</td>
<td>
O(2^n) Exponential
</td>
</tr>
</tbody>
</table>
<ul>
<li>First we apply the product rule to drop all constants.</li>
<li>Then we apply the sum rule to select the single most dominant term.</li>
</ul>
<hr />
<h2 id="complexity-classes"><strong>Complexity Classes</strong></h2>
<p><strong>Common Complexity Classes</strong></p>
<blockquote>
<p>There are 7 major classes in Time Complexity</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>
Big O
</th>
<th>
Complexity Class Name
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
O(1)
</td>
<td>
Constant
</td>
</tr>
<tr class="even">
<td>
O(log(n))
</td>
<td>
Logarithmic
</td>
</tr>
<tr class="odd">
<td>
O(n)
</td>
<td>
Linear
</td>
</tr>
<tr class="even">
<td>
O(nlog(n))
</td>
<td>
Loglinear, Linearithmetic, Quasilinear
</td>
</tr>
<tr class="odd">
<td>
O(nc) - O(n2), O(n3), etc.
</td>
<td>
Polynomial
</td>
</tr>
<tr class="even">
<td>
O(cn) - O(2n), O(3n), etc.
</td>
<td>
Exponential
</td>
</tr>
<tr class="odd">
<td>
O(n!)
</td>
<td>
Factorial
</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong><code>O(1) Constant</code></strong></p>
<ul>
<li><p>The algorithm takes roughly the same number of steps for any input size.</p>
<p>// O(1) function constant1(n) { return n * 2 + 1; }</p>
<p>// O(1) function constant2(n) { for (let i = 1; i &lt;= 100; i++) { console.log(i); } }</p></li>
</ul></li>
<li><p><strong><code>O(log(n)) Logarithmic</code></strong></p>
<ul>
<li><p>In most cases our hidden base of Logarithmic time is 2, log complexity algo’s will typically display ‘halving’ the size of the input (like binary search!)</p>
<p>// O(log(n)) function logarithmic1(n) { if (n &lt;= 1) return; logarithmic1(n / 2); }</p>
<p>// O(log(n)) function logarithmic2(n) { let i = n; while (i &gt; 1) { i /= 2; } }</p></li>
</ul></li>
<li><p><strong><code>O(n) Linear</code></strong></p>
<ul>
<li><p>Linear algo’s will access each item of the input “once”.</p>
<p>// O(n) function linear1(n) { for (let i = 1; i &lt;= n; i++) { console.log(i); } }</p>
<p>// O(n), where n is the length of the array function linear2(array) { for (let i = 0; i &lt; array.length; i++) { console.log(i); } }</p>
<p>// O(n) function linear3(n) { if (n === 1) return; linear3(n - 1); }</p></li>
</ul></li>
<li><strong><code>O(nlog(n)) Log Linear Time</code></strong>
<ul>
<li>Combination of linear and logarithmic behavior, we will see features from both classes.</li>
<li>Algo’s that are log-linear will use both recursion AND iteration.</li>
</ul>
<p>// O(n * log(n)) function loglinear(n) { if (n &lt;= 1) return;</p>
<p>for (let i = 1; i &lt;= n; i++) { console.log(i); }</p>
<p>loglinear(n / 2); loglinear(n / 2); }</p></li>
<li><strong><code>O(nc) Polynomial</code></strong>
<ul>
<li>C is a fixed constant.</li>
</ul>
<p>// O(n^2) function quadratic(n) { for (let i = 1; i &lt;= n; i++) { for (let j = 1; j &lt;= n; j++) {} } }</p>
<p>// O(n^3) function cubic(n) { for (let i = 1; i &lt;= n; i++) { for (let j = 1; j &lt;= n; j++) { for (let k = 1; k &lt;= n; k++) {} } } }</p></li>
<li><p>Example of Quadratic and Cubic runtime.</p></li>
<li><strong><code>O(c^n) Exponential</code></strong>
<ul>
<li>C is now the number of recursive calls made in each stack frame.</li>
<li>Algo’s with exponential time are VERY SLOW.</li>
</ul>
<p>// O(2^n) function exponential2n(n) { if (n === 1) return; exponential_2n(n - 1); exponential_2n(n - 1); }</p>
<p>// O(3^n) function exponential3n(n) { if (n === 0) return; exponential_3n(n - 1); exponential_3n(n - 1); exponential_3n(n - 1); }</p></li>
<li><strong><code>O(n!) Factorial</code></strong>
<ul>
<li>The largest/ worst complexity (minus DTIME which is n^n);</li>
</ul></li>
</ul>
<hr />
<h2 id="memoization"><strong>Memoization</strong></h2>
<ul>
<li><strong>Memoization</strong> : a design pattern used to reduce the overall number of calculations that can occur in algorithms that use recursive strategies to solve.
<ul>
<li>MZ stores the results of the sub-problems in some other data structure, so that we can avoid duplicate calculations and only ‘solve’ each problem once.</li>
<li>Two features that comprise memoization:
<ul>
<li><ol type="1">
<li>FUNCTION MUST BE RECURSIVE.</li>
</ol></li>
<li><ol type="1">
<li>Our additional DS is usually an object (we refer to it as our memo!)</li>
</ol></li>
</ul></li>
</ul></li>
</ul>
<p><strong>Memoizing Factorial</strong></p>
<pre><code>let memo = {};

function factorial(n) {
  // if this function has calculated factorial(n) previously,
  // fetch the stored result in memo
  if (n in memo) return memo[n];
  if (n === 1) return 1;

  // otherwise, it havs not calculated factorial(n) previously,
  // so calculate it now, but store the result in case it is
  // needed again in the future
  memo[n] = n * factorial(n - 1);
  return memo[n];
}

factorial(6); // =&gt; 720, requires 6 calls
factorial(6); // =&gt; 720, requires 1 call
factorial(5); // =&gt; 120, requires 1 call
factorial(7); // =&gt; 5040, requires 2 calls

memo; // =&gt; { &#39;2&#39;: 2, &#39;3&#39;: 6, &#39;4&#39;: 24, &#39;5&#39;: 120, &#39;6&#39;: 720, &#39;7&#39;: 5040 }</code></pre>
<ul>
<li>Our memo object is <em>mapping</em> out our arguments of factorial to it’s return value.
<ul>
<li>Keep in mind we didn’t improve the speed of our algo.</li>
</ul></li>
</ul>
<p><strong>Memoizing Fibonacci</strong> <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/memoization/images/fib_memoized.png" alt="memofib" /></p>
<ul>
<li>Our time complexity for fibonacci goes from O(2^n) to O(n) after applying memoization.</li>
</ul>
<p><strong>The Memoization Formula</strong></p>
<blockquote>
<p>Rules</p>
</blockquote>
<ol type="1">
<li>Write the unoptimized brute force recursion (make sure it works);</li>
<li>Add memo object as an additional arugmnt .</li>
<li>Add a base case condition that returns the stored value if the function’s argument is in the memo.</li>
<li>Before returning the result of the recursive case, store it in the memo as a value and make the function’s argument it’s key.</li>
</ol>
<blockquote>
<p>Things to remember</p>
</blockquote>
<ol type="1">
<li>When solving DP problems with Memoization, it is helpful to draw out the visual tree first.</li>
<li>When you notice duplicate sub-tree’s that means we can memoize.</li>
</ol>
<hr />
<h2 id="section">**</h2>
<pre><code>function fastFib(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n === 1 || n === 2) return 1;

  memo[n] = fastFib(n - 1, memo) + fastFib(n - 2, memo);
  return memo[n];
}

fastFib(6); // =&gt; 8
fastFib(50); // =&gt; 12586269025</code></pre>
<hr />
<h2 id="tabulation"><strong>Tabulation</strong></h2>
<ul>
<li><strong>Tabulation Strategy</strong>
<ul>
<li>Use When:
<ul>
<li>The function is iterative and not recursive.</li>
<li>The accompanying DS is usually an array.</li>
</ul></li>
</ul>
<p>function fib(n) { let mostRecentCalcs = [0, 1];</p>
<p>if (n === 0) return mostRecentCalcs[0];</p>
<p>for (let i = 2; i &lt;= n; i++) { const [secondLast, last] = mostRecentCalcs; mostRecentCalcs = [last, secondLast + last]; }</p>
<p>return mostRecentCalcs[1]; }</p></li>
<li>Steps for tabulation
<ul>
<li>Create a table array based off the size of the input.</li>
<li>Initialize some values in the table to ‘answer’ the trivially small subproblem.</li>
<li>Iterate through the array and fill in the remaining entries.</li>
<li>Your final answer is usually the last entry in the table.</li>
</ul></li>
</ul>
<h1 id="class-examples"><strong>Class Examples</strong></h1>
<h2 id="example-of-linear-search"><strong>Example of Linear Search</strong></h2>
<pre><code>function search(array, term) {
  for (let i = 0; i &lt; array.length; i++) {
    if (array[i] === term) {
      return i;
    }
  }
  return -1;
}</code></pre>
<ul>
<li>Worst Case Scenario: The term does not even exist in the array.</li>
<li>Meaning: If it doesn’t exist then our for loop would run until the end therefore making our time complexity O(n).</li>
</ul>
<h2 id="example-of-binary-search"><strong>Example of Binary Search</strong></h2>
<pre><code>function binarySearch(arr, x, start, end) {
  if (start &gt; end) return false;

  let mid = Math.floor((start + end) / 2);
  if (arr[mid] === x) return true;

  if (arr[mid] &gt; x) {
    return binarySearch(arr, x, start, mid - 1);
  } else {
    return binarySearch(arr, x, mid + 1, end);
  }
}</code></pre>
<ul>
<li>Must be conducted on a sorted array.</li>
<li>Binary search is logarithmic time, not exponential b/c n is cut down by two, not growing.</li>
<li>Binary Search is part of Divide and Conquer.</li>
</ul>
<h2 id="example-of-merge-sort"><strong>Example of Merge Sort</strong></h2>
<pre><code>function merge(leftArray, rightArray) {
  const sorted = [];
  while (letArray.length &gt; 0 &amp;&amp; rightArray.length &gt; 0) {
    const leftItem = leftArray[0];
    const rightItem = rightArray[0];

    if (leftItem &gt; rightItem) {
      sorted.push(rightItem);
      rightArray.shift();
    } else {
      sorted.push(leftItem);
      leftArray.shift();
    }
  }

  while (leftArray.length !== 0) {
    const value = leftArray.shift();
    sorted.push(value);
  }

  while (rightArray.length !== 0) {
    const value = rightArray.shift();
    sorted.push(value);
  }

  return sorted;
}

function mergeSort(array) {
  const length = array.length;
  if (length === 1) {
    return array;
  }

  const middleIndex = Math.ceil(length / 2);
  const leftArray = array.slice(0, middleIndex);
  const rightArray = array.slice(middleIndex, length);

  leftArray = mergeSort(leftArray);
  rightArray = mergeSort(rightArray);

  return merge(leftArray, rightArray);
}</code></pre>
<hr />
<h2 id="example-of-bubble-sort"><strong>Example of Bubble Sort</strong></h2>
<pre><code>function bubbleSort(items) {
  var length = items.length;
  for (var i = 0; i &lt; length; i++) {
    for (var j = 0; j &lt; length - i - 1; j++) {
      if (items[j] &gt; items[j + 1]) {
        var tmp = items[j];
        items[j] = items[j + 1];
        items[j + 1] = tmp;
      }
    }
  }
}</code></pre>
<ul>
<li>Worst Case &amp; Best Case are always the same because it makes nested loops.</li>
<li>Double for loops are polynomial time complexity or more specifically in this case Quadratic big O O(n^2); # <strong>Notes</strong></li>
</ul>
<h2 id="sorting-algorithms"><strong>Sorting Algorithms</strong></h2>
<h2 id="bubble-sort"><strong>Bubble Sort</strong></h2>
<ul>
<li>The first major sorting algorithm one learns in introductory programming courses.</li>
<li>Gives an intro on how to convert unsorted data into sorted data.</li>
<li>It’s almost never used in production code because:
<ul>
<li>It’s not efficient</li>
<li>It’s not commonly used</li>
<li>There is stigma attached to it</li>
</ul></li>
<li><p><strong><code>Bubbling Up</code></strong> : Term that infers that an item <em>is in motion</em>, <em>moving in some direction</em>, and <em>has some final resting destination</em>.</p></li>
<li><p>Bubble sort, sorts an array of integers by bubbling the largest integer to the top. <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/naive_sorting_algorithms/bubble_sort/images/BubbleSort.gif" alt="bubble" /></p>
<p>// Bubble Sort function bubble(array) { let sorted = true; for (let i = 0; i &lt; array.length; i++) { let num1 = array[i]; let num2 = array[i + 1]; if (num1 &gt; num2) { array[i + 1] = num1; array[i] = num2; sorted = false; } } if (sorted) { return array; } else { return bubble(array); } }</p></li>
</ul>
<hr />
<h2 id="selection-sort"><strong>Selection Sort</strong></h2>
<ul>
<li>Selection sort organizes the smallest elements to the start of the array. <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/naive_sorting_algorithms/selection_sort/images/SelectionSort.gif" alt="selection" /></li>
<li>Summary of how Selection Sort should work:
<ol type="1">
<li>Set MIN to location 0</li>
<li>Search the minimum element in the list.</li>
<li>Swap with value at location Min</li>
<li>Increment Min to point to next element.</li>
<li>Repeat until list is sorted.</li>
</ol>
let selectionSort = (arr) =&gt; { let len = arr.length; for (let i = 0; i &lt; len; i++) { let min = i; for (let j = i + 1; j &lt; len; j++) { if (arr[min] &gt; arr[j]) { min = j; } } if (min !== i) { let tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; } } return arr; };</li>
</ul>
<h2 id="selection-sort-1"><strong>Selection Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Quadratic O(n^2)</p>
<ul>
<li>Our outer loop will contribute O(n) while the inner loop will contribute O(n / 2) on average. Because our loops are nested we will get O(n^2);</li>
</ul>
<p><strong><code>Space Complexity</code></strong>: O(1)</p>
<ul>
<li>Selection Sort will always use the same amount of memory regardless of n.</li>
</ul>
<p><img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/naive_sorting_algorithms/selection_sort/images/SelectionSort.gif" alt="selection" /> <img src="https://www.w3resource.com/w3r_images/selection-short.png" alt="se" /></p>
<blockquote>
<p>Class Solution</p>
</blockquote>
<pre><code>function swap(array, idx1, idx2) {
  [array[idx1], array[idx2]] = [array[idx2], array[idx2]];
}

function selectionSort(array) {
  for (let i = 0; i &lt; array.length; i++) {
    let lowest = i;
    for (let j = i + 1; j &lt; array.length; j++) {
      if (list[j] &lt; list[lowest]) {
        lowest = j;
      }
    }
    if (place !== i) {
      swap(array, i, lowest);
    }
  }
}</code></pre>
<blockquote>
<p>Alt Solution</p>
</blockquote>
<pre><code>function selectionSort(array) {
  for (let i = 0; i &lt; array.length; i++) {
    let lowest = i;
    for (let j = 0; j &lt; array.length; j++) {
      if (array[j] &lt; array[i]) {
        lowest = j;
      }
    }
    if (lowest !== i) {
      let temp = array[i];
      array[i] = array[lowest];
      array[lowest] = temp;
    }
  }
  return array;
}</code></pre>
<hr />
<h2 id="insertion-sort"><strong>Insertion Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Quadratic O(n^2)</p>
<ul>
<li>Our outer loop will contribute O(n) while the inner loop will contribute O(n / 2) on average. Because our loops are nested we will get O(n^2);</li>
</ul>
<p><strong><code>Space Complexity</code></strong>: O(n)</p>
<ul>
<li>Because we are creating a subArray for each element in the original input, our Space Comlexity becomes linear.</li>
</ul>
<p><img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/naive_sorting_algorithms/insertion_sort/images/InsertionSort.gif" alt="insertion" /> <img src="https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png" alt="insert" /></p>
<blockquote>
<p>Class Solution</p>
</blockquote>
<pre><code>function insertionSort(array) {
  for (let i = 1; i &lt; array.length; i++) {
    let value = list[i];
    let hole = i;
    while (hole &gt; 0 &amp;&amp; list[hole - 1] &gt; value) {
      list[hole] = list[hole - 1];
      hole--;
    }
    list[hole] = value;
  }
  return array;
}</code></pre>
<blockquote>
<p>Alt Solution</p>
</blockquote>
<pre><code>function insertionSort(arr) {
  for (let i = 1; i &lt; arr.length; i++) {
    let current = arr[i];
    let j = i - 1;
    while (j &gt; -1 &amp;&amp; current &lt; arr[j]) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = current;
  }
  return arr;
}</code></pre>
<hr />
<h2 id="merge-sort"><strong>Merge Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Log Linear O(nlog(n))</p>
<ul>
<li>Since our array gets split in half every single time we contribute O(log(n)). The while loop contained in our helper merge function contributes O(n) therefore our time complexity is O(nlog(n)); <strong><code>Space Complexity</code></strong>: O(n)</li>
<li>We are linear O(n) time because we are creating subArrays. <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/efficient_sorting_algorithms/merge_sort/images/MergeSort.gif" alt="nmer" /> <img src="https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png" alt="dmwio" /></li>
</ul>
<blockquote>
<p>Class Solution</p>
</blockquote>
<pre><code>function merge(arr1, arr2) {
  let result = [];
  while (arr1.length &amp;&amp; arr2.length) {
    if (arr1[0] &lt; arr2[0]) {
      result.push(arr1.shift());
    } else {
      result.push(arr2.shift());
    }
  }
  return [...result, ...arr1, ...arr2];
}

function mergeSort(arr) {
  if (arr.length &lt;= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}</code></pre>
<hr />
<h2 id="quick-sort"><strong>Quick Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Quadratic O(n^2)</p>
<ul>
<li>Even though the average time complexity O(nLog(n)), the worst case scenario is always quadratic.</li>
</ul>
<p><strong><code>Space Complexity</code></strong>: O(n)</p>
<ul>
<li><p>Our space complexity is linear O(n) because of the partition arrays we create. <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/efficient_sorting_algorithms/quick_sort/images/QuickSort.gif" alt="quick" /> <img src="https://www.w3resource.com/w3r_images/quick-sort-part-1.png" alt="qs" /></p>
<p>function quickSort(array) { if (array.length &lt;= 1) return array;</p>
<p>let pivot = array.shift();</p>
<p>let left = array.filter((x) =&gt; x &lt; pivot); let right = array.filter((x) =&gt; x &gt;= pivot);</p>
<p>let sortedLeft = quickSort(left); let sortedRight = quickSort(right);</p>
<p>return […sortedLeft, pivot, …sortedRight]; }</p></li>
</ul>
<hr />
<h2 id="binary-search"><strong>Binary Search</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Log Time O(log(n))</p>
<p><strong><code>Space Complexity</code></strong>: O(1) <img src="https://www.geeksforgeeks.org/wp-content/uploads/Binary-Search.png" alt="bin" /></p>
<blockquote>
<p>Recursive Solution</p>
</blockquote>
<pre><code>function binarySearch(array, target) {
  if (array.length === 0) return false;

  let midPt = Math.floor(array.length / 2);

  if (array[midPt] === target) {
    return true;
  } else if (list[midPt] &gt; target) {
    return binarySearch(list.slice(0, mid), target);
  } else {
    return binarySearch(list.slice(midPt + 1), target);
  }
}</code></pre>
<blockquote>
<p>Min Max Solution</p>
</blockquote>
<pre><code>function binarySearch(array, target) {
  let start = 0;
  let end = array.length - 1;

  while (start &lt;= end) {
    let midpoint = Math.floor((start + end) / 2);

    if (target === array[midpoint]) {
      return midpoint;
    }

    if (target &gt; array[midpoint]) {
      start = midpoint + 1;
    }

    if (target &lt; array[midpoint]) {
      end = midpoint - 1;
    }
  }
  return -1;
}</code></pre>
<hr />
<h2 id="insertion-sort-1"><strong>Insertion Sort</strong></h2>
<figure>
<img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/naive_sorting_algorithms/insertion_sort/images/InsertionSort.gif" alt="insert" /><figcaption>insert</figcaption>
</figure>
<ul>
<li>Works by building a larger and larger sorted region at the left-most end of the array.</li>
<li>Steps:
<ol type="1">
<li>If it is the first element, and it is already sorted; return 1.</li>
<li>Pick next element.</li>
<li>Compare with all elements in the sorted sub list</li>
<li>Shift all the elemnts in the sorted sub list that is greater than the value to be sorted.</li>
<li>Insert the value</li>
<li>Repeat until list is sorted.</li>
</ol>
let insertionSort = (inputArr) =&gt; { let length = inputArr.length; for (let i = 1; i &lt; length; i++) { let key = inputArr[i]; let j = i - 1; while (j &gt;= 0 &amp;&amp; inputArr[j] &gt; key) { inputArr[j + 1] = inputArr[j]; j = j - 1; } inputArr[j + 1] = key; } return inputArr; };</li>
</ul>
<hr />
<h2 id="merge-sort-1"><strong>Merge Sort</strong></h2>
<figure>
<img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/efficient_sorting_algorithms/merge_sort/images/MergeSort.gif" alt="merge" /><figcaption>merge</figcaption>
</figure>
<ul>
<li>Merge sort is nlogn time.</li>
<li>We need a function for merging and a function for sorting.</li>
<li>Steps:
<ol type="1">
<li>If there is only one element in the list, it is already sorted; return the array.</li>
<li>Otherwise, divide the list recursively into two halves until it can no longer be divided.</li>
<li>Merge the smallest lists into new list in a sorted order.</li>
</ol>
<p>const merge = (arr1, arr2) =&gt; { let sorted = [];</p>
<p>while (arr1.length &amp;&amp; arr2.length) { if (arr1[0] &lt; arr2[0]) sorted.push(arr1.shift()); else sorted.push(arr2.shift()); }</p>
<p>return sorted.concat(arr1.slice().concat(arr2.slice())); };</p>
<p>const mergeSort = (arr) =&gt; { if (arr.length &lt;= 1) return arr; let mid = Math.floor(arr.length / 2), left = mergeSort(arr.slice(0, mid)), right = mergeSort(arr.slice(mid));</p>
<p>return merge(left, right); };</p></li>
</ul>
<hr />
<h2 id="quick-sort-1"><strong>Quick Sort</strong></h2>
<ul>
<li>QS is another Divide and Conquer strategy.</li>
<li>Some key ideas to keep in mind:
<ul>
<li>It is easy to sort elements of an array relative to a particular target value.</li>
<li>An array of 0 or 1 elements is already trivially sorted. <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/efficient_sorting_algorithms/quick_sort/images/QuickSort.gif" alt="quicksort" /></li>
</ul>
<p>function quick_Sort(origArray) { if (origArray.length &lt;= 1) { return origArray; } else { var left = []; var right = []; var newArray = []; var pivot = origArray.pop(); var length = origArray.length;</p>
<pre><code>for (var i = 0; i &lt; length; i++) {
  if (origArray[i] &lt;= pivot) {
    left.push(origArray[i]);
  } else {
    right.push(origArray[i]);
  }
}

return newArray.concat(quick_Sort(left), pivot, quick_Sort(right));</code></pre>
<p>} }</p></li>
</ul>
<p><strong>binary search</strong></p>
<pre><code>const binarySearch = (array, target) =&gt; {
  let startIndex = 0;
  let endIndex = array.length - 1;
  while(startIndex &lt;= endIndex) {
    let middleIndex = Math.floor((startIndex + endIndex) / 2);
    if(target === array[middleIndex) {
      return console.log(&quot;Target was found at index &quot; + middleIndex);
    }
    if(target &gt; array[middleIndex]) {
      console.log(&quot;Searching the right side of Array&quot;)
      startIndex = middleIndex + 1;
    }
    if(target &lt; array[middleIndex]) {
      console.log(&quot;Searching the left side of array&quot;)
      endIndex = middleIndex - 1;
    }
    else {
      console.log(&quot;Not Found this loop iteration. Looping another iteration.&quot;)
    }
  }

  console.log(&quot;Target value not found in array&quot;);
}</code></pre>
<h1 id="notes-1"><strong>Notes</strong></h1>
<h2 id="linked-lists"><strong>Linked Lists</strong></h2>
<ul>
<li>A <strong><code>linked list</code></strong> represents a linear sequence of ‘vertices’ or ‘nodes’ and tracks three properties.
<ul>
<li><strong><code>Head</code></strong> : The first node in the list.</li>
<li><strong><code>Tail</code></strong> : The last node in the list.</li>
<li><strong><code>Length</code></strong> : The number of nodes in the list; the list’s length.</li>
</ul></li>
<li><strong><code>Nodes</code></strong> : Simpler, smaller data structure that connects the linked list.</li>
<li>Node Properties:
<ul>
<li><strong><code>Value</code></strong> : THe actual value this node represents.</li>
<li><strong><code>Next</code></strong> : The next node in the list (relative to this node).</li>
<li><strong><code>Previous</code></strong> : The previous node in the list (relative to this node).</li>
</ul></li>
</ul>
</body>
</html>
