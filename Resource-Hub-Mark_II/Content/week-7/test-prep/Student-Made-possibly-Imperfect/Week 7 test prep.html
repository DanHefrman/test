<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Week 7 test prep</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p><img src="media/image1.png" /></p>
<p><img src="media/image2.png" /></p>
<p><img src="media/image3.png" /></p>
<p><img src="media/image4.png" /></p>
<p><img src="media/image5.png" /></p>
<p><img src="media/image6.png" /></p>
<p><img src="media/image7.png" /></p>
<p><img src="media/image8.png" /></p>
<p><img src="media/image9.png" /></p>
<p><img src="media/image10.png" /></p>
<p><img src="media/image11.png" /></p>
<p><img src="media/image12.png" /></p>
<p><img src="media/image13.png" /></p>
<p><img src="media/image14.png" /></p>
<p><img src="media/image15.png" /></p>
<p><img src="media/image16.png" /></p>
<p><img src="media/image17.png" /></p>
<p><img src="media/image18.png" /></p>
<p><img src="media/image19.png" /></p>
<p><img src="media/image20.png" /></p>
<p><img src="media/image21.png" /></p>
<p><img src="media/image22.png" /></p>
<p><img src="media/image23.png" /></p>
<p><img src="media/image24.png" /></p>
<p><img src="media/image25.png" /></p>
<p><img src="media/image26.png" /></p>
<p><img src="media/image27.png" /></p>
<p><img src="media/image28.png" /></p>
<p><em>//! Single Linked List</em></p>
<p>class Node {</p>
<p>    constructor(val) {</p>
<p>        <em>this</em>.value = val;</p>
<p>        <em>this</em>.next = null;</p>
<p>    }</p>
<p>}</p>
<p>class LinkedList {</p>
<p>    constructor() {</p>
<p>        <em>this</em>.head = null;</p>
<p>        <em>this</em>.tail = null;</p>
<p>        <em>this</em>.length = 0;</p>
<p>    }</p>
<p>    addToTail(val) {</p>
<p>        const newNode = new Node(val);</p>
<p>        <em>if</em> (!<em>this</em>.head) {</p>
<p>            <em>this</em>.head = newNode;</p>
<p>        } <em>else</em> {</p>
<p>            <em>this</em>.tail.next = newNode;</p>
<p>        }</p>
<p>        <em>this</em>.tail = newNode;</p>
<p>        <em>this</em>.length++;</p>
<p>        <em>return</em> <em>this</em>;</p>
<p>    }</p>
<p>    </p>
<p>removeTail() {</p>
<p>        <em>if</em> (!<em>this</em>.head) <em>return</em> undefined;</p>
<p>        let current = <em>this</em>.head;</p>
<p>        let newTail = current;</p>
<p>        <em>while</em> (current.next) {</p>
<p>            newTail = current;</p>
<p>            current = current.next;</p>
<p>        }</p>
<p>        <em>this</em>.tail = newTail;</p>
<p>        <em>this</em>.tail.next = null;</p>
<p>        <em>this</em>.length–;</p>
<p>        <em>if</em> (<em>this</em>.length === 0) {</p>
<p>            <em>this</em>.head = null;</p>
<p>            <em>this</em>.tail = null;</p>
<p>        }</p>
<p>        <em>return</em> current;</p>
<p>    }</p>
<p>    </p>
<p>addToHead(val) {</p>
<p>        let newNode = new Node(val);</p>
<p>        <em>if</em> (!<em>this</em>.head) {</p>
<p>            <em>this</em>.head = newNode;</p>
<p>            <em>this</em>.tail = newNode;</p>
<p>        } <em>else</em> {</p>
<p>            newNode.next = <em>this</em>.head;</p>
<p>            <em>this</em>.head = newNode;</p>
<p>        }</p>
<p>        <em>this</em>.length++;</p>
<p>        <em>return</em> <em>this</em>;</p>
<p>    }</p>
<p>    </p>
<p>removeHead() {</p>
<p>        <em>if</em> (!<em>this</em>.head) <em>return</em> undefined;</p>
<p>        const currentHead = <em>this</em>.head;</p>
<p>        <em>this</em>.head = currentHead.next;</p>
<p>        <em>this</em>.length–;</p>
<p>        <em>if</em> (<em>this</em>.length === 0) {</p>
<p>            <em>this</em>.tail = null;</p>
<p>        }</p>
<p>        <em>return</em> currentHead;</p>
<p>    }</p>
<p>    contains(target) {</p>
<p>        let node = <em>this</em>.head;</p>
<p>        <em>while</em> (node) {</p>
<p>            <em>if</em> (node.value === target) <em>return</em> true;</p>
<p>            node = node.next;</p>
<p>        }</p>
<p>        <em>return</em> false;</p>
<p>    }</p>
<p>    </p>
<p>get(index) {</p>
<p>        <em>if</em> (index &lt; 0 || index &gt;= <em>this</em>.length) <em>return</em> null;</p>
<p>        let counter = 0;</p>
<p>        let current = <em>this</em>.head;</p>
<p>        <em>while</em> (counter !== index) {</p>
<p>            current = current.next;</p>
<p>            counter++;</p>
<p>        }</p>
<p>        <em>return</em> current;</p>
<p>    }</p>
<p>    </p>
<p>set(index, val) {</p>
<p>        const foundNode = <em>this</em>.get(index);</p>
<p>        <em>if</em> (foundNode) {</p>
<p>            foundNode.value = val;</p>
<p>            <em>return</em> true;</p>
<p>        }</p>
<p>        <em>return</em> false;</p>
<p>    }</p>
<p>    insert(index, val) {</p>
<p>        <em>if</em> (index &lt; 0 || index &gt; <em>this</em>.length) <em>return</em> false;</p>
<p>        <em>if</em> (index === <em>this</em>.length) <em>return</em> !!<em>this</em>.addToTail(val);</p>
<p>        <em>if</em> (index === 0) <em>return</em> !!<em>this</em>.addToHead(val);</p>
<p>        const newNode = new Node(val);</p>
<p>        const prev = <em>this</em>.get(index - 1);</p>
<p>        const temp = prev.next;</p>
<p>        prev.next = newNode;</p>
<p>        newNode.next = temp;</p>
<p>        <em>this</em>.length++;</p>
<p>        <em>return</em> true;</p>
<p>    }</p>
<p>   </p>
<p> remove(index) {</p>
<p>        <em>if</em> (index &lt; 0 || index &gt;= <em>this</em>.length) <em>return</em> undefined;</p>
<p>        <em>if</em> (index === 0) <em>return</em> <em>this</em>.removeHead();</p>
<p>        <em>if</em> (index === <em>this</em>.length - 1) <em>return</em> <em>this</em>.removeTail();</p>
<p>        const previousNode = <em>this</em>.get(index - 1);</p>
<p>        const removed = previousNode.next;</p>
<p>        previousNode.next = removed.next;</p>
<p>        <em>this</em>.length–;</p>
<p>        <em>return</em> removed;</p>
<p>    }</p>
<p>    size() {</p>
<p>        <em>return</em> <em>this</em>.length;</p>
<p>    }</p>
<p>}</p>
<p>exports.Node = Node;</p>
<p>exports.LinkedList = LinkedList;</p>
<p><em>//!Queue Array:</em></p>
<p><em>// Using the first element of the array as the “front” of the queue</em></p>
<p>class QueueArray {</p>
<p>    constructor() {</p>
<p>        <em>this</em>.queue = [];</p>
<p>    }</p>
<p>    enqueue(value) {</p>
<p>        <em>this</em>.queue.push(value);</p>
<p>    }</p>
<p>    dequeue() {</p>
<p>        <em>return</em> <em>this</em>.queue.shift();</p>
<p>    }</p>
<p>    peek() {</p>
<p>        <em>return</em> <em>this</em>.queue[0];</p>
<p>    }</p>
<p>}</p>
<p><em>// Using the last element of the array as the “front” of the queue</em></p>
<p>class QueueArray {</p>
<p>    constructor() {</p>
<p>        <em>this</em>.queue = [];</p>
<p>    }</p>
<p>    enqueue(value) {</p>
<p>        <em>this</em>.queue.unshift(value);</p>
<p>    }</p>
<p>    dequeue() {</p>
<p>        <em>return</em> <em>this</em>.queue.pop();</p>
<p>    }</p>
<p>    peek() {</p>
<p>        <em>return</em> <em>this</em>.queue[<em>this</em>.queue.length - 1];</p>
<p>    }</p>
<p>}</p>
<p><em>//! Queue Node</em></p>
<p>class Node {</p>
<p>    constructor(val) {</p>
<p>        <em>this</em>.value = val;</p>
<p>        <em>this</em>.next = null;</p>
<p>    }</p>
<p>}</p>
<p>class Queue {</p>
<p>    constructor() {</p>
<p>        <em>this</em>.front = null;</p>
<p>        <em>this</em>.back = null;</p>
<p>        <em>this</em>.length = 0;</p>
<p>    }</p>
<p>    </p>
<p>enqueue(val) {</p>
<p>        const newNode = new Node(val);</p>
<p>        <em>if</em> (!<em>this</em>.front) {</p>
<p>            <em>this</em>.front = newNode;</p>
<p>            <em>this</em>.back = newNode;</p>
<p>        } <em>else</em> {</p>
<p>            <em>this</em>.back.next = newNode;</p>
<p>            <em>this</em>.back = newNode;</p>
<p>        }</p>
<p>        <em>return</em> ++<em>this</em>.length;</p>
<p>    }</p>
<p>    </p>
<p>dequeue() {</p>
<p>        <em>if</em> (!<em>this</em>.front) {</p>
<p>            <em>return</em> null;</p>
<p>        }</p>
<p>        const temp = <em>this</em>.front;</p>
<p>        <em>if</em> (<em>this</em>.front === <em>this</em>.back) {</p>
<p>            <em>this</em>.back = null;</p>
<p>        }</p>
<p>        <em>this</em>.front = <em>this</em>.front.next;</p>
<p>        <em>this</em>.length–;</p>
<p>        <em>return</em> temp.value;</p>
<p>    }</p>
<p>    size() {</p>
<p>        <em>return</em> <em>this</em>.length;</p>
<p>    }</p>
<p>}</p>
<p><em>//!Stack Array</em></p>
<p><em>// Using the last element of the array as the “top” of the stack</em></p>
<p><em>// This is more efficient than the second implementation because we can push and</em></p>
<p><em>// pop from an array in O(1) time since we don’t have to reassign any indices.</em></p>
<p>class StackArray {</p>
<p>    constructor() {</p>
<p>        <em>this</em>.stack = [];</p>
<p>    }</p>
<p>    push(value) {</p>
<p>        <em>this</em>.stack.push(value);</p>
<p>    }</p>
<p>    pop() {</p>
<p>        <em>return</em> <em>this</em>.stack.pop();</p>
<p>    }</p>
<p>    peek() {</p>
<p>        <em>return</em> <em>this</em>.stack[<em>this</em>.stack.length - 1];</p>
<p>    }</p>
<p>}</p>
<p><em>// Using the first element of the array as the “top” of the stack</em></p>
<p><em>// This is not as efficient as the previous implementation since we have to</em></p>
<p><em>// reassign indices for a shift and unshift, but the user will see the same</em></p>
<p><em>// functionality.</em></p>
<p>class StackArray {</p>
<p>    constructor() {</p>
<p>        <em>this</em>.stack = [];</p>
<p>    }</p>
<p>    push(value) {</p>
<p>        <em>this</em>.stack.unshift(value);</p>
<p>    }</p>
<p>    pop() {</p>
<p>        <em>return</em> <em>this</em>.stack.shift();</p>
<p>    }</p>
<p>    peek() {</p>
<p>        <em>return</em> <em>this</em>.stack[0];</p>
<p>    }</p>
<p>}</p>
<p>class Node {</p>
<p>    constructor(value) {</p>
<p>        <em>this</em>.value = value;</p>
<p>        <em>this</em>.next = null;</p>
<p>    }</p>
<p>}</p>
<p>class StackNode {</p>
<p>    constructor() {</p>
<p>        <em>this</em>.top = null;</p>
<p>        <em>this</em>.length = 0;</p>
<p>    }</p>
<p>    </p>
<p>push(val) {</p>
<p>        const newNode = new Node(val);</p>
<p>        <em>if</em> (!<em>this</em>.top) {</p>
<p>            <em>this</em>.top = newNode;</p>
<p>        } <em>else</em> {</p>
<p>            const temp = <em>this</em>.top;</p>
<p>            <em>this</em>.top = newNode;</p>
<p>            <em>this</em>.top.next = temp;</p>
<p>        }</p>
<p>        <em>this</em>.length++;</p>
<p>        <em>return</em> <em>this</em>.length;</p>
<p>    }</p>
<p>    </p>
<p>pop() {</p>
<p>        <em>if</em> (!<em>this</em>.top) {</p>
<p>            <em>return</em> null;</p>
<p>        }</p>
<p>        const temp = <em>this</em>.top;</p>
<p>        <em>this</em>.top = <em>this</em>.top.next;</p>
<p>        <em>this</em>.length–;</p>
<p>        <em>return</em> temp.value;</p>
<p>    }</p>
<p>    peek() {</p>
<p>        <em>if</em> (!<em>this</em>.top) {</p>
<p>            <em>return</em> null;</p>
<p>        }</p>
<p>        <em>return</em> <em>this</em>.top.value;</p>
<p>    }</p>
<p>   </p>
<p> size() {</p>
<p>        <em>return</em> <em>this</em>.length;</p>
<p>    }</p>
<p>}</p>
</body>
</html>
