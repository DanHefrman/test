<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Sorting-Algo</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="sorting-algorithms"><strong>Sorting Algorithms</strong></h1>
<h2 id="bubble-sort"><strong>Bubble Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Quadratic O(n^2)</p>
<ul>
<li>The inner for-loop contributes to O(n), however in a worst case scenario the while loop will need to run n times before bringing all n elements to their final resting spot.</li>
</ul>
<p><strong><code>Space Complexity</code></strong>: O(1)</p>
<ul>
<li>Bubble Sort will always use the same amount of memory regardless of n.</li>
</ul>
<p><img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/naive_sorting_algorithms/bubble_sort/images/BubbleSort.gif" alt="bubble" /> <img src="https://www.w3resource.com/w3r_images/bubble-short.png" alt="bub" /></p>
<blockquote>
<p>Class Solution</p>
</blockquote>
<pre><code>function swap(array, idx1, idx2) {
  [array[idx1], array[idx2]] = [array[idx2], array[idx1]];
}

function bubbleSort(array) {
  let swapped = false;
  while (!swapped) {
    swapped = true;
    for (let i = 0; i &lt; array.length; i++) {
      if (array[i] &gt; array[i + 1]) {
        swap(array, i, i + 1);
        swapped = false;
      }
    }
  }
  return array;
}</code></pre>
<blockquote>
<p>Alt Solution</p>
</blockquote>
<pre><code>function bubbleSort(array) {
  let sorted = false;
  while (!sorted) {
    sorted = true;
    for (let i = 0; i &lt; array.length; i++) {
      if (array[i] &gt; array[i + 1]) {
        let temp = arr[i];
        array[i] = array[i + 1];
        array[i + 1] = temp;
        sorted = false;
      }
    }
  }
  return array;
}</code></pre>
<hr />
<h2 id="selection-sort"><strong>Selection Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Quadratic O(n^2)</p>
<ul>
<li>Our outer loop will contribute O(n) while the inner loop will contribute O(n / 2) on average. Because our loops are nested we will get O(n^2);</li>
</ul>
<p><strong><code>Space Complexity</code></strong>: O(1)</p>
<ul>
<li>Selection Sort will always use the same amount of memory regardless of n.</li>
</ul>
<p><img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/naive_sorting_algorithms/selection_sort/images/SelectionSort.gif" alt="selection" /> <img src="https://www.w3resource.com/w3r_images/selection-short.png" alt="se" /></p>
<blockquote>
<p>Class Solution</p>
</blockquote>
<pre><code>function swap(array, idx1, idx2) {
  [array[idx1], array[idx2]] = [array[idx2], array[idx2]];
}

function selectionSort(array) {
  for (let i = 0; i &lt; array.length; i++) {
    let lowest = i;
    for (let j = i + 1; j &lt; array.length; j++) {
      if (list[j] &lt; list[lowest]) {
        lowest = j;
      }
    }
    if (place !== i) {
      swap(array, i, lowest);
    }
  }
}</code></pre>
<blockquote>
<p>Alt Solution</p>
</blockquote>
<pre><code>function selectionSort(array) {
  for (let i = 0; i &lt; array.length; i++) {
    let lowest = i;
    for (let j = 0; j &lt; array.length; j++) {
      if (array[j] &lt; array[i]) {
        lowest = j;
      }
    }
    if (lowest !== i) {
      let temp = array[i];
      array[i] = array[lowest];
      array[lowest] = temp;
    }
  }
  return array;
}</code></pre>
<hr />
<h2 id="insertion-sort"><strong>Insertion Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Quadratic O(n^2)</p>
<ul>
<li>Our outer loop will contribute O(n) while the inner loop will contribute O(n / 2) on average. Because our loops are nested we will get O(n^2);</li>
</ul>
<p><strong><code>Space Complexity</code></strong>: O(n)</p>
<ul>
<li>Because we are creating a subArray for each element in the original input, our Space Comlexity becomes linear.</li>
</ul>
<p><img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/naive_sorting_algorithms/insertion_sort/images/InsertionSort.gif" alt="insertion" /> <img src="https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png" alt="insert" /></p>
<blockquote>
<p>Class Solution</p>
</blockquote>
<pre><code>function insertionSort(array) {
  for (let i = 1; i &lt; array.length; i++) {
    let value = list[i];
    let hole = i;
    while (hole &gt; 0 &amp;&amp; list[hole - 1] &gt; value) {
      list[hole] = list[hole - 1];
      hole--;
    }
    list[hole] = value;
  }
  return array;
}</code></pre>
<blockquote>
<p>Alt Solution</p>
</blockquote>
<pre><code>function insertionSort(arr) {
  for (let i = 1; i &lt; arr.length; i++) {
    let current = arr[i];
    let j = i - 1;
    while (j &gt; -1 &amp;&amp; current &lt; arr[j]) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = current;
  }
  return arr;
}</code></pre>
<hr />
<h2 id="merge-sort"><strong>Merge Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Log Linear O(nlog(n))</p>
<ul>
<li>Since our array gets split in half every single time we contribute O(log(n)). The while loop contained in our helper merge function contributes O(n) therefore our time complexity is O(nlog(n)); <strong><code>Space Complexity</code></strong>: O(n)</li>
<li>We are linear O(n) time because we are creating subArrays. <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/efficient_sorting_algorithms/merge_sort/images/MergeSort.gif" alt="nmer" /> <img src="https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png" alt="dmwio" /></li>
</ul>
<blockquote>
<p>Class Solution</p>
</blockquote>
<pre><code>function merge(arr1, arr2) {
  let result = [];
  while (arr1.length &amp;&amp; arr2.length) {
    if (arr1[0] &lt; arr2[0]) {
      result.push(arr1.shift());
    } else {
      result.push(arr2.shift());
    }
  }
  return [...result, ...arr1, ...arr2];
}

function mergeSort(arr) {
  if (arr.length &lt;= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}</code></pre>
<hr />
<h2 id="quick-sort"><strong>Quick Sort</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Quadratic O(n^2)</p>
<ul>
<li>Even though the average time complexity O(nLog(n)), the worst case scenario is always quadratic.</li>
</ul>
<p><strong><code>Space Complexity</code></strong>: O(n)</p>
<ul>
<li><p>Our space complexity is linear O(n) because of the partition arrays we create. <img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/efficient_sorting_algorithms/quick_sort/images/QuickSort.gif" alt="quick" /> <img src="https://www.w3resource.com/w3r_images/quick-sort-part-1.png" alt="qs" /></p>
<p>function quickSort(array) { if (array.length &lt;= 1) return array;</p>
<p>let pivot = array.shift();</p>
<p>let left = array.filter((x) =&gt; x &lt; pivot); let right = array.filter((x) =&gt; x &gt;= pivot);</p>
<p>let sortedLeft = quickSort(left); let sortedRight = quickSort(right);</p>
<p>return […sortedLeft, pivot, …sortedRight]; }</p></li>
</ul>
<hr />
<h2 id="binary-search"><strong>Binary Search</strong></h2>
<p><strong><code>Time Complexity</code></strong>: Log Time O(log(n))</p>
<p><strong><code>Space Complexity</code></strong>: O(1) <img src="https://www.geeksforgeeks.org/wp-content/uploads/Binary-Search.png" alt="bin" /></p>
<blockquote>
<p>Recursive Solution</p>
</blockquote>
<pre><code>function binarySearch(array, target) {
  if (array.length === 0) return false;

  let midPt = Math.floor(array.length / 2);

  if (array[midPt] === target) {
    return true;
  } else if (list[midPt] &gt; target) {
    return binarySearch(list.slice(0, mid), target);
  } else {
    return binarySearch(list.slice(midPt + 1), target);
  }
}</code></pre>
<blockquote>
<p>Min Max Solution</p>
</blockquote>
<pre><code>function binarySearch(array, target) {
  let start = 0;
  let end = array.length - 1;

  while (start &lt;= end) {
    let midpoint = Math.floor((start + end) / 2);

    if (target === array[midpoint]) {
      return midpoint;
    }

    if (target &gt; array[midpoint]) {
      start = midpoint + 1;
    }

    if (target &lt; array[midpoint]) {
      end = midpoint - 1;
    }
  }
  return -1;
}</code></pre>
<hr />
</body>
</html>
