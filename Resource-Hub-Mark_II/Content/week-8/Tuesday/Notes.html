<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Notes</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="notes"><strong>Notes</strong></h1>
<h2 id="binary-trees"><strong>Binary Trees</strong></h2>
<figure>
<img src="https://s3-us-west-1.amazonaws.com/appacademy-open-assets/data_structures_algorithms/trees/images/graphs.png" alt="graphs" /><figcaption>graphs</figcaption>
</figure>
<ul>
<li><strong><code>Graph</code></strong> : A collection of nodes and any edges between those nodes. (Linked Lists and Trees are both considered subclasses of graphs)</li>
<li><strong><code>Tree</code></strong> : Graph that does not contain any cycles.
<ul>
<li>In CS we only refer to trees that are “<code>rooted</code>”, or a tree where there exists a node that is accessible from every other node.</li>
</ul></li>
<li><strong><code>Binary Tree</code></strong> : Tree where nodes have at most 2 children.</li>
</ul>
<figure>
<img src="https://assets.aaonline.io/data_structures_algorithms/trees/images/graph_a.png" alt="tree" /><figcaption>tree</figcaption>
</figure>
<pre><code>class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

a.left = b;
a.right = c;
b.left = d;
b.right = e;
c.right = f;</code></pre>
<ul>
<li>Common way to implement a binary tree is by using a node class with OOP.</li>
</ul>
<p><strong>Basic Tree Terminology</strong></p>
<ul>
<li><strong><code>Tree</code></strong> : Graph with no cycles.
<ul>
<li>Cycle is a path through edges that begins and ends at the same node.</li>
<li>In CS, trees must have roots!</li>
</ul></li>
<li><strong><code>Binary Tree</code></strong> : Tree where nodes have at most 2 nodes.</li>
<li><strong><code>Root</code></strong> : The ultimate parent, the single node s tree that can access every other node through edges; root does not have a parent.</li>
<li><strong><code>Internal Node</code></strong> : Node that has children.</li>
<li><strong><code>Leaf</code></strong> : Node that does not have any children.</li>
<li><strong><code>Path</code></strong> : A series of nodes that can be traveled through edges.</li>
</ul>
<p><strong>Traversing Trees</strong></p>
<ul>
<li>Trees can be traveresed in multiple ways: Depth-First or Breadth-First.</li>
<li>Three common ways to go depth-first:
<ul>
<li>In-Order</li>
<li>Pre-Order</li>
<li>Post-Order</li>
</ul></li>
<li><p><strong><code>Breadth First</code></strong> : Traversing level by level, visiting every node at each stage.</p>
<pre><code>    A
   / \
  B   C
 /   / \
D   E   F</code></pre>
<p>A, B, C, D, E, F</p></li>
<li><p><strong><code>Depth-First</code></strong> :</p>
<pre><code>    A
   / \
  B   C
 /   / \
D   E   F</code></pre>
<p>A, B, D, C, E, F</p></li>
</ul>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/d/dc/Sorted_binary_tree_ALL.svg" alt="pic" /><figcaption>pic</figcaption>
</figure>
<ul>
<li><p><strong><code>Pre-Order Traversal</code></strong> :</p>
<ul>
<li>F, B, A, D, C, E, G, I, H</li>
<li>Access data of the current Node</li>
<li>Recursively visit the left sub tree</li>
<li>Recursively visit the right sub tree</li>
</ul></li>
<li><p><strong><code>In-Order Traversal</code></strong> :</p>
<ul>
<li>A, B, C, D, E, F, G, H, I</li>
<li>Recursively visit the left sub tree</li>
<li>Access the data of the current node</li>
<li>Recursively visit the right sub tree</li>
</ul></li>
<li><p><strong><code>Post-Order Traversal</code></strong> :</p>
<ul>
<li>A, C, E, D, B, H, I, G, F</li>
<li>Recursively visit the left sub tree</li>
<li>Recursively visit the right sub tree</li>
<li>Access the data of the current node</li>
</ul></li>
</ul>
<p><strong><code>Binary Search Trees</code></strong></p>
<ul>
<li>A Binary Tree is a <strong>Binary Search Tree</strong> if:
<ul>
<li>The left subtree contains values less than the root.</li>
<li>AND the right subtree contains values greater than or equal to the root</li>
<li>AND the left subtree is a Binary Search Tree</li>
<li>AND the right subtree is a Binary Search Tree</li>
</ul></li>
</ul>
<figure>
<img src="https://assets.aaonline.io/data_structures_algorithms/binary_search_trees/images/bsts.png" alt="bst" /><figcaption>bst</figcaption>
</figure>
<ul>
<li>BSTs are sorted Data Structures</li>
<li><p>If this printing function is called on a BST, the values will be print out in ascending order.</p>
<p>function inOrderPrint(root) { if (!root) return;</p>
<p>inOrderPrint(root.left); console.log(root.val); inOrderPrint(root.right); } // BST 1: 42 // BST 2: 4, 5, 6 // BST 3: 1, 5, 7, 10, 16, 16</p></li>
<li><p>The best BSTs are <strong>height balanced</strong>.</p></li>
</ul>
<hr />
</body>
</html>
