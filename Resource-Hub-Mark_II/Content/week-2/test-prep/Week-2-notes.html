<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Week-2-notes</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="monday">Monday ——————————–</h1>
<h1 id="notes"><strong>Notes</strong></h1>
<h2 id="terminal-basics"><strong>Terminal Basics</strong></h2>
<p><strong><code>The terminal</code></strong> is a text based system that allows you, as a user, to control your computer and do everything from creating new files and folders to starting up entire applications.</p>
<ul>
<li>Mac &amp; Linux use <strong><code>The Terminal</code></strong></li>
<li>Windows uses <strong><code>The Command Prompt</code></strong></li>
</ul>
<p><strong>Descriptions of Programs we Installed</strong></p>
<ul>
<li><strong><code>VSCODE</code></strong> : a free source-code editor made by Microsoft for Windows, Linux and macOS.</li>
<li><strong><code>Node</code></strong> : an open-source, cross-platform, JavaScript runtime environment that executes JavaScript code outside a web browser.</li>
<li><strong><code>NPM</code></strong> : a package manager for the JavaScript programming language.</li>
<li><strong><code>Mocha</code></strong> : a JavaScript test framework for Node.js programs.</li>
<li><strong><code>Xcode Command Line Tools</code></strong> : The Command Line Tool package gives Mac terminal users many commonly used tools, utilities, and compilers</li>
<li><strong><code>Homebrew</code></strong> : a free and open-source software package management system that simplifies the installation of software.</li>
<li><strong><code>Python 3</code></strong> : an interpreted, high-level, general-purpose programming language.</li>
</ul>
<hr />
<h2 id="file-tree"><strong>File Tree</strong></h2>
<ul>
<li><strong><code>Directory</code></strong> : Same as a folder on your computer; a directory can contain many files or subdirectories (folders within themselves)</li>
<li><strong><code>Root</code></strong> : The outermost main directory of our computer represented by /</li>
<li><strong><code>Path</code></strong> : Location on your computer specified by directories. <code>/Desktop/photos/cats.pdf</code> is an example of a path.</li>
<li><strong><code>CLI</code></strong> : The Command Line Interface is the text-based user interface used to view and manage computer files.
<ul>
<li>Predates the GUI, and many coding specific programs can only be run from the CL (such as Node)!</li>
</ul></li>
<li><strong><code>GUI</code></strong> : The Graphic User Interface is the visual alternative of the CLI, it is what we have been using to navigate our computers so far.</li>
</ul>
<hr />
<h2 id="basic-terminal-navigation"><strong>Basic Terminal Navigation</strong></h2>
<p><strong>Unix</strong> refers to the parent operating system upon which Mac is built on and Linux is inspired by.</p>
<ul>
<li>They have <em>nearly identical</em> commands and features.</li>
<li>The terminal dafaults into <strong><code>~</code></strong> (<strong>tilde</strong>) which denotes your <strong><code>home directory</code></strong>.</li>
</ul>
<p><strong>Navigation Commands</strong></p>
<ul>
<li><strong><code>ls</code></strong> : lists all files and subdirectories in the current directory.</li>
<li><strong><code>cd [path]</code></strong> : changes the current directory to the directory specified by the <em>path</em> argument.</li>
<li><strong><code>pwd</code></strong> : The present working directory command lists the path from your current location starting from root.</li>
<li><strong><code>clear</code></strong> : Clears your terminal.</li>
</ul>
<p><strong>Directory Shortcuts</strong></p>
<ul>
<li>You can use <strong><code>cd ..</code></strong> or <strong><code>cd</code></strong> by itself to quickly naviagte to your previous directory.</li>
<li>If you hit <strong>tab</strong> you can auto-complete your submission in the terminal (if there are multiple matches your terminal will list them out for you to choose.)</li>
<li>You can drag and drop folders from the GUI into the terminal to auto-populate the full path!</li>
</ul>
<hr />
<h2 id="using-node-js"><strong>Using Node JS</strong></h2>
<p>Javascript is the <strong>language of the internet</strong>!</p>
<ul>
<li>The two main environments we use to run Javascript are: <strong><code>Google Chrome</code></strong> &amp; <strong><code>Node</code></strong>.</li>
<li><strong><code>Node</code></strong> is a very powerful runtime environment built on Google Chrome’s Javascript V8 Engine.</li>
<li><strong><code>Runtime Environment</code></strong> : A runtime system that is used to implement portions of an execution model.</li>
</ul>
<p><strong>Node REPL vs. Javascript File</strong></p>
<ul>
<li>There are two ways to run Javascript using Node:
<ul>
<li>Using the <strong><code>Node REPL</code></strong>
<ul>
<li>Used for testing quick ideas.</li>
<li>Useful when playing around with curiosities because the expression is evaluated very quickly.</li>
<li>Any code you enter into the REPL will be deleted upon exiting.</li>
</ul></li>
<li>Using Node to run a <strong><code>.js file</code></strong>
<ul>
<li>Used for saving files for the long term.</li>
</ul></li>
</ul></li>
</ul>
<p><strong>Using the Node REPL</strong></p>
<p>To enter the Node REPL simply type <code>node</code> into your terminal, you will be greeted with a <code>&gt;</code> character - here you can type any JS code, and even define functions! (Just keep in mind these will not be saved)</p>
<ul>
<li>To exit node, type <strong><code>. exit</code></strong> or ctrl + c.</li>
</ul>
<p><strong>Using Javascript Files</strong></p>
<ul>
<li>Create a folder via Terminal by using <strong><code>mkdir &lt;folder name&gt;</code></strong>.</li>
<li>Create a JS file via Terminal by using <strong><code>touch &lt;file name.js&gt;</code></strong>.</li>
<li>To run a JS file via Terminal type <strong><code>node &lt;file name&gt;</code></strong>.</li>
</ul>
<hr />
<h2 id="navigating-in-vscode"><strong>Navigating in VSCode</strong></h2>
<p>VCSode is an <strong>IDE</strong> (<strong><code>Interactive Developer Environment</code></strong>).</p>
<blockquote>
<p>Please keep in mind that keeping an organized file system will save you a lot of trouble in the future!</p>
</blockquote>
<p><strong>VSCode Shortcuts</strong></p>
<ul>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf">Shortcuts for MacOS</a></li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">Shortcuts for Windows</a></li>
</ul>
<hr />
<h1 id="tuesday">Tuesday———————————————————</h1>
<h1 id="notes-1"><strong>Notes</strong></h1>
<h2 id="the-object-type"><strong>The Object Type</strong></h2>
<p>The <strong><code>object</code></strong> is a data structure that stores other data, similar to how an array stores elements.</p>
<ul>
<li>The object differs in that each <strong><code>value</code></strong> stores in an obj is associated with a <strong><code>key</code></strong>.</li>
</ul>
<p><strong>The Object of My Affections</strong></p>
<p>In other programming languages, objects are referred to as, “dictionaries”, “maps”, or “associative arrays”.</p>
<ul>
<li>Objects are indexed with <strong><code>keys</code></strong> instead of numbers.</li>
<li>Order is not guaranteed within an Object.</li>
<li>Objects are defined by using curly braces <strong><code>{}</code></strong></li>
<li>You can think of Objects as tables.</li>
</ul>
<blockquote>
<p>Fun Fact: Objects are affectionately known as POJO’s (Plain Old Javascript Objects)</p>
</blockquote>
<p><strong>Setting Keys and Values</strong></p>
<pre><code>// here &quot;color&quot; is the key!
&gt; car[&quot;color&quot;] = &quot;Blue&quot;;
&quot;Blue&quot;

&gt; car[&quot;seats&quot;] = 2;
2

// accessing our object at the key of color
&gt; car[&quot;color&quot;]
&quot;Blue&quot;

&gt; car[&quot;seats&quot;]
2

&gt; car
{color: &quot;Blue&quot;, seats: 2}</code></pre>
<ul>
<li><p>We assign values to an object by defining the name of the key in brackets and assigning it to a value.</p>
<blockquote>
<p>car {color: “Blue”, seats: 2}</p>
</blockquote>
<blockquote>
<p>“color” in car; true</p>
</blockquote>
<blockquote>
<p>“model” in car; false</p>
</blockquote></li>
<li>If we try to access a key that has not yet been assigned within an object we will output undefined.</li>
<li><p>The <strong>preferred method</strong> for checking to see if an object exists at a key is to use the <strong><code>in</code></strong> operator.</p></li>
</ul>
<p><strong>Using Variables as Keys</strong></p>
<pre><code>&gt; car
{color: &quot;Blue&quot;, seats: 2}

&gt; let newVariable = &quot;color&quot;;
undefined

&gt; newVariable
&quot;color&quot;

&gt; car[newVariable]
&quot;Blue&quot;

---

&gt; car
{color: &quot;Blue&quot;, seats: 2}

&gt; newVariable
&quot;weight&quot;

// assigning a key value pair using a variable!
&gt; car[newVariable] = 1000;
1000

&gt; car
{color: &quot;Blue&quot;, seats: 2, weight: 1000}</code></pre>
<ul>
<li>It is useful to set a variable as a key, because variables can be re-assigned new values - this way we can quickly access different data and also create new key/value pairs.</li>
</ul>
<h2 id="using-different-notations"><strong>Using Different Notations</strong></h2>
<pre><code>&gt; let dog = {};
undefined

&gt; dog.bark = &quot;Bowowowo&quot;;
&quot;Bowowowowo&quot;

&gt; dog.bark
&quot;Bowowowo&quot;

&gt; dog
{ bark: &quot;Bowowowowo&quot; }</code></pre>
<ul>
<li>We can also use <strong>dot notation</strong> <strong>“.”</strong> to access key/value pairs in an object.
<ul>
<li>One thing to note is that when using dot notation, we do not have to use string quotes as the key.</li>
</ul></li>
</ul>
<p><strong>Bracket Notation vs Dot Notation</strong></p>
<table style="width:99%;">
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>
<strong>Dot</strong>
</th>
<th>
<strong>Bracket</strong>
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
Easier To Read
</td>
<td>
You can use variables as keys!
</td>
</tr>
<tr class="even">
<td>
Easier To Write b/c do not need Quotations.
</td>
<td>
Okay to use variables and Strings that start with numbers.
</td>
</tr>
<tr class="odd">
<td>
Cannot access with Variables
</td>
<td>
</td>
</tr>
<tr class="even">
<td>
Keys cannot contain numbers as their first character
</td>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>When accessing object keys</strong>: Bracket notation needs to refer to that key in quotations, dot notation doesn’t.</li>
<li><p><strong>When accessing object keys via a variable</strong>: Bracket notation can refer to that key w/o use of quotations, dot notation can’t do this at all.</p>
<p>let myDog = {}; myDog.name = “Fido”;</p>
<p>let myKey = “name”; console.log(myDog); // prints <code>{name: "Fido"}</code> console.log(myDog[myKey]); // prints <code>Fido</code></p>
<p>console.log(myDog.myKey); // prints: undefined</p></li>
<li><p>As illustrated above, the dot notation cannot access a varible key - since it takes a <strong>literal</strong> interpretation of the key.</p></li>
</ul>
<p><strong>Putting it All Together</strong></p>
<p>You can put an object together in a single statement.</p>
<pre><code>let myDog = {
    name: &quot;Fido&quot;,
    type: &quot;Doge&quot;,
    age: 2,
    favoriteToys: [&quot;bone&quot;, &quot;ball&quot;],
};</code></pre>
<p><strong>Operator Precedence Revisited</strong></p>
<ul>
<li>The concept of Operator Precedence also applies to objects.</li>
<li>There are two types of associativity:
<ul>
<li><p><strong><code>Right Associativity</code></strong> : When code is evaluted right to left.</p>
<pre><code>a = b = 1;</code></pre>
<ul>
<li>Since <strong>assignment of variables</strong> takes lowest precendence, we end up evaluating b = 1 first before a = b.</li>
</ul></li>
<li><p><strong><code>Left Associativity</code></strong> : When code is evaluated left to right.</p>
<pre><code>let id = &quot;header&quot;;
let element = document.getElementById(id).value;</code></pre>
<ul>
<li>We first resolve the document variable, then use dot notation to retrive the getElementById function, we eval it’s arguments, access it’s value, and then retrieve assignment (the lowest precedence).</li>
</ul></li>
</ul></li>
</ul>
<hr />
<h2 id="iterating-through-objects"><strong>Iterating Through Objects</strong></h2>
<p>Because objects store <strong><em>unordered</em></strong> key-value pairs, we do not rely on indices to access values; instead we rely on our keys.</p>
<p><strong>A New Kind of For Loop</strong></p>
<pre><code>for (let variable in object) {
    statement;

    let obj = { name: &quot;Rose&quot;, cats: 2 };
    for (let currentKey in obj) {
        console.log(currentKey);
        console.log(obj[currentKey]);
    }

    // prints out:
    // name
    // cats
    // Rose
    // 2
}</code></pre>
<ul>
<li>We use a special syntax to iterate through each key of an object called a <strong><code>for-in loop</code></strong>.</li>
</ul>
<p><strong>Methods vs Functions</strong></p>
<p>A <strong><code>Method</code></strong> is a function that <em>belongs</em> to an object. Every method is a function, but <em>not</em> every function is a method.</p>
<pre><code>myFunc is a function
myObject.myFunc is a method of the object myObject
myObject[&quot;myFunc&quot;] is a method of the object myObject</code></pre>
<ul>
<li><p><strong>Methods</strong> are just a key-value pair where the <strong>key is the function name and the value is the function definition</strong>.</p>
<p>let dog = { name: “Fido”, };</p>
<p>dog.bark = function () { console.log(“bark bark!”); };</p>
<p>// this is the same thing as above just using Bracket Notation dog[“speak”] = function (string) { console.log(“WOOF” + string + " WOOF!!!"); };</p>
<p>dog.bark(); // prints <code>bark bark!</code> dog.speak(“pizza”); // prints <code>WOOF pizza WOOF!!!</code></p>
<p>let dog2 = { name: “Rover”,</p>
<pre><code>bark: function () {
    console.log(&quot;bork bork!&quot;);
},

speak: function (string) {
    console.log(&quot;BORK &quot; + string + &quot; BORK!!!&quot;);
},</code></pre>
<p>}; // Notice that in the object above, we still separate the key-value pairs with commas. // <code>bark</code> and <code>speak</code> are just keys with functions as values.</p>
<p>dog2.bark(); // prints <code>bork bork!</code> dog2.speak(“burrito”); // prints <code>BORK burrito BORK!!!</code></p></li>
<li><p>To invoke these methods we just need to specify which object is calling that method.</p>
<p>myObject.methodName();</p></li>
</ul>
<p><strong>Useful Object Methods</strong></p>
<ul>
<li><strong><code>Object.keys()</code></strong> : A method that allows us to iterate through keys, it accepts an obj as the argument and returns an array of the keys.</li>
<li><strong><code>Object.values()</code></strong> : Method that accepts an object as the argument and returns an array of the values.</li>
</ul>
<p><strong>Iterating through an Object’s keys &amp; values</strong></p>
<ul>
<li><p><strong><code>Object.entries</code></strong> : Method that accepts an object as the argument and returns an array of the [key,value] pairs within.</p>
<blockquote>
<p>Object.entries(cat) [ [ ‘name’, ‘Freyja’ ], [ ‘color’, ‘orange’ ] ]</p>
</blockquote></li>
</ul>
<hr />
<h2 id="references-vs-primitives"><strong>References vs Primitives</strong></h2>
<p><strong>Primitives vs Objects</strong></p>
<p>So far we have learned about 6 different data types:</p>
<ul>
<li><strong>Primitive</strong> : Boolean, Null, Undefined, Number, String.</li>
<li><strong>Reference</strong> : Object (Arrays are a type of object)</li>
<li>Remember that <strong>primitive</strong> types are immutable!</li>
</ul>
<p><strong>Immutabiity</strong></p>
<figure>
<img src="https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-JavaScript/pojo/assets/assignment-num2.png" alt="pic of nums" /><figcaption>pic of nums</figcaption>
</figure>
<ul>
<li>When we reassign primitives we simply have our variable point elsewhere in memory.</li>
<li>In a nutshell, <strong>immutability</strong> cannot change values in memory, but only reassign where our variables are pointing to.</li>
</ul>
<p><strong>Mutabulity</strong></p>
<figure>
<img src="https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-JavaScript/pojo/assets/assignment-num5.png" alt="img of mut" /><figcaption>img of mut</figcaption>
</figure>
<ul>
<li>If we change either cat1 or cat2, our computer memory will change because they are both pointing at the same memory location.</li>
</ul>
<hr />
<h2 id="rest-and-spread"><strong>Rest and Spread</strong></h2>
<p><strong>Using the Spread Operator and Rest Parameter Syntax</strong> <strong>Accepting Arguments</strong></p>
<ul>
<li>Just keep in mind that function will still run even if it is not passed any arguments.</li>
<li>Parameters will take just as many arguments they need even if more than enough are offered.</li>
<li>We will encounter an error if there are not enough parameters ( &gt; 0).</li>
</ul>
<p><strong>Utilizing Rest Parameters</strong></p>
<ul>
<li><strong><code>Rest Parameter Syntax</code></strong> : Allows us to capture all of a function’s incoming arguments into an array.</li>
<li>Only the last parameter can be a rest parameter.</li>
</ul>
<p><strong>Utilizing Spread Syntax</strong></p>
<ul>
<li><strong>Spread Operator</strong> : Allows us to break down a data type into the elements that make it up.
<ul>
<li>Takes a data type (i.e. array, obj) and spreads the values of that type where elements are expected.</li>
<li>Takes iterable data and spreads the elements of that type where arguments are expected.</li>
</ul>
<p>let numArray = [1, 2, 3];</p>
<p>// here we are taking <code>numArray</code> and <em>spreading</em> it into a new array where // comma separated elements are expected to be let moreNums = […numArray, 4, 5, 6];</p>
<blockquote>
<p>moreNums // =&gt; [1, 2, 3, 4, 5, 6]</p>
</blockquote></li>
</ul>
<p><strong>With Objects</strong></p>
<pre><code>let colors = { red: &quot;scarlet&quot;, blue: &quot;aquamarine&quot; };
let newColors = { ...colors };

&gt; newColors
// { red: &quot;scarlet&quot;, blue: &quot;aquamarine&quot; };

let colors = { red: &quot;scarlet&quot;, blue: &quot;aquamarine&quot; };
let colors2 = { green: &quot;forest&quot;, yellow: &quot;sunflower&quot; };

let moreColors = { ...colors, ...colors2 };

&gt; moreColors
// {red: &quot;scarlet&quot;, blue: &quot;aquamarine&quot;, green: &quot;forest&quot;, yellow: &quot;sunflo</code></pre>
<p><strong>Spreading Arguments</strong></p>
<pre><code>function speak(verb, noun) {
    return &quot;I like to go &quot; + verb + &quot; with &quot; + noun + &quot;.&quot;;
}

const words = [&quot;running&quot;, &quot;Jet&quot;];

console.log(speak(&quot;running&quot;, &quot;Jet&quot;)); // =&gt; I like to go running with Jet.
console.log(speak(...words)); // =&gt; I like to go running with Jet.</code></pre>
<hr />
<h2 id="destructuring"><strong>Destructuring</strong></h2>
<ul>
<li><p><strong><code>Destructuring Syntax</code></strong> : Allows you to extract parts of an array or obj intro distinct variables.</p>
<p>let numArray = [10, 20];</p>
<p>// here we are “unpacking” the array values into two separate variables let [firstEl, secondEl] = numArray;</p>
<p>console.log(firstEl); //=&gt; 10 console.log(secondEl); //=&gt; 20</p></li>
</ul>
<p><strong>Swapping Variables using destructuring</strong></p>
<pre><code>let num1 = 17;
let num2 = 3;

// this syntax will swap the values of the two variables
[num1, num2] = [num2, num1];

console.log(num1); // 3
console.log(num2); // 17</code></pre>
<ul>
<li>One of the cool things we can do with destructuring is swap the values of two variables.</li>
</ul>
<p><strong>Destructuring objects into variables</strong></p>
<ul>
<li><p>One of the most useful parts of destructuring is the ability to take apart and assign little slices of large objs to variables.</p>
<p>let obj = { name: “Apples”, breed: [“tabby”, “short hair”] }; let { name, breed } = obj;</p>
<p>console.log(name); // “Apples” console.log(breed); // [“tabby”, “short hair”]</p></li>
<li><p><strong>Aliased Object Destructuring</strong> : When our variable does not have the same name as our object’s keys.</p>
<p>let obj = { apple: “red”, banana: “yellow” }; let { apple: newApple, banana: newBanana } = obj;</p>
<p>console.log(newApple); // “red” console.log(newBanana); // “yellow”</p></li>
<li><p>Good rule of thumb to keep clarity in your code is to only destructure values from objects that are two levels deep.</p>
<p>// the fname key is nested more than two levels deep // (within bootcamp.instructor.fullName) let bootcamp = { name: “App Academy”, color: “red”, instructor: { fullName: { fname: “Rose”, lname: “K”, }, }, };</p>
<p>// this is hard to follow: let { instructor: { fullName: { fname, lname }, }, } = bootcamp; console.log(fname, lname);</p>
<p>// this is much easier to read: let { fname, lname } = bootcamp.instructor.fullName; console.log(fname, lname);</p></li>
</ul>
<p><strong>Destructuring and the Rest Pattern</strong></p>
<pre><code>let foods = [&quot;pizza&quot;, &quot;ramen&quot;, &quot;sushi&quot;, &quot;kale&quot;, &quot;tacos&quot;];

let [firstFood, secondFood, ...otherFoods] = foods;
console.log(firstFood); // =&gt; &quot;pizza&quot;
console.log(secondFood); // =&gt; &quot;ramen&quot;
console.log(otherFoods); // =&gt; [&quot;sushi&quot;, &quot;kale&quot;, &quot;tacos&quot;]</code></pre>
<ul>
<li><p>Currently the rest pattern is only officially supported by JS when destructuring arrays.</p>
<p>let { a, c, …obj } = { a: 1, b: 2, c: 3, d: 4 }; console.log(a); // =&gt; 1 console.log(c); // =&gt; 3 console.log(obj); // =&gt; { b: 2, d: 4 }</p></li>
</ul>
<hr />
<h2 id="destructuring-parameters"><strong>Destructuring Parameters</strong></h2>
<p>We can also destructure <strong>incoming parameters</strong> of a function. This is very useful when we’re passing objects around to different functions.</p>
<pre><code>let cat = { name: &quot;Rupert&quot;, owner: &quot;Curtis&quot;, weight: 10 };

// This unpacks the *owner* key out of any incoming object argument and
// assigns it to a owner parameter(variable)
function ownerName({ owner }) {
    console.log(&quot;This cat is owned by &quot; + owner);
}

ownerName(cat);

let bigCat = {
    name: &quot;Jet&quot;,
    owner: { name: &quot;Rose&quot; },
    toys: [&quot;ribbon&quot;],
    siblings: { name: &quot;Freyja&quot;, color: &quot;orange&quot;, toys: [&quot;mouse&quot;, &quot;string&quot;] },
};

// here we use *aliased* object destructuring to create a siblingToys variable
function toyFinder({ toys, siblings: { toys: siblingToys } }) {
    let allToys = toys.concat(siblingToys);
    return allToys;
}

console.log(toyFinder(bigCat)); // =&gt; [&quot;ribbon&quot;, &quot;mouse&quot;, &quot;string&quot;]</code></pre>
<h2 id="plain-old-js-object-lesson-learning-objectives-w2d2---learning-objectives">Plain Old JS Object Lesson Learning Objectives (W2D2) - Learning Objectives</h2>
<ol type="1">
<li>Label variables as either Primitive vs. Reference There are 5 primitive data types: Boolean, Null, Undefined, Number, String 1 Reference Type: Object (arrays are a kind of object)</li>
<li><p>Identify when to use . vs [] when accessing values of an object:</p>
<p>//Using <a href="bracket"></a> notation</p>
<p>let person = {};</p>
<p>person[“firstName”] = “Jesse”; console.log(person); person[“firstName”] = “Steven”;</p>
<p>console.log(person);</p>
<p>//Using . (dot) notation</p>
<p>let person = {};</p>
<p>person.name = “Brian”; console.log(person); person.name = “Steven”; console.log(person);</p></li>
<li><p>Use the obj[key] !== undefined pattern to check if a given variable that contains a key exists in an object</p></li>
</ol>
<h1 id="checking-for-undefinied-with-bracket-notation">Checking for Undefinied with bracket notation</h1>
<pre><code>let person = {};
person.name = &quot;Paul&quot;;
person.age = 25;
console.log(person);
console.log(person[&quot;name&quot;] === &quot;Paul&quot;);
console.log(person[&quot;age&quot;] === 25);
console.log(person[&quot;occupation&quot;] === undefined);
console.log(person[&quot;occupation&quot;] !== undefined);</code></pre>
<ol type="1">
<li><p>Utilize Object.keys and Object.values in a function</p>
<p>//Object.keys</p>
<p>let cars = { make: “honda”, model: “civic” }; console.log(Object.keys(cars));</p>
<p>//Object.values</p>
<p>let cars = { make: “honda”, model: “civic” }; console.log(Object.values(cars));</p></li>
<li><p>Iterate through an object using a for in loop</p>
<p>let obj = { game: “call of duty”, console: “PC duh?” };</p>
<p>for (let keys in obj) { let values = obj[keys]; console.log(“Here are the key value pairs!”, keys, “-”, values); }</p></li>
<li><p>Define a function that utilizes …rest syntax to accept an arbitrary number of arguments</p>
<p>let acceptEverything = function (…everything) { console.log(everything); };</p>
<p>acceptEverything(“thing1”, “thing2”, “thing3”);</p></li>
<li><p>Use …spread syntax for Object literals and Array literals</p>
<p>let arrayOfNums = [0, 1, 2, 3, 4];</p>
<p>let moreNums = […arrayOfNums, 5, 6, 7, 8, 9];</p>
<p>console.log(moreNums);</p>
<p>let hubby = { firstName: “John”, lastName: “Doe” }; let wifey = { firsName: “Jane”, lastName: “Doe” };</p>
<p>let couple = { …hubby, …wifey }; //Something interesting happens here console.log(couple);</p>
<p>let person1 = { name: “Jack”, faveColor: “red” }; let person2 = { name: “Paul”, faveColor: “blue” }; let people = { …person1, …person2 }; console.log(people);</p></li>
<li><p>Destructure an array to reference specific elements</p>
<p>let nums = [1, 2];</p>
<p>let [num1, num2] = nums;</p>
<p>console.log(“num1 variable”, num1, " num2 variable", num2);</p></li>
<li><p>Destructure an object to reference specific values</p>
<p>let person = { name: “Kelly”, getFaveColor: function () { return “blue”; }, friends: { name: “Ryan”, }, };</p>
<p>let { friends: { name }, } = person;</p>
<p>console.log(“name”, person.name); console.log(“favorite color”, person.getFaveColor()); console.log(name);</p></li>
<li><p>Write a function that accepts a array as an argument and returns an object representing the count of each character in the array</p>
<p>let myCounter = function (array) { let myObj = {}; let count = 1; array.forEach(function (char) { if (myObj[char] === undefined) { myObj[char] = count; } else { myObj[char]++; } }); return myObj; };</p>
<p>console.log(myCounter([“a”, “a”, “n”, “c”]));</p></li>
</ol>
<h1 id="wednesday">Wednesday —————————————————————————————————————————–</h1>
<h1 id="notes-2"><strong>Notes</strong></h1>
<h2 id="callbacks-using-a-function-as-an-argument"><strong>Callbacks: Using a Function as an Argument</strong></h2>
<p><strong>What is a callback?</strong></p>
<ul>
<li><p>A <strong><code>callback</code></strong> is always a function that is being passed into another function.</p>
<p>let foobar = function (callback) { console.log(“foo”); callback(); console.log(“bar”); };</p>
<p>let sayHello = function () { console.log(“hello”); };</p>
<p>foobar(sayHello); // prints // foo // hello // bar</p></li>
<li><p>Although we named our parameter <em>callback</em>, we could name it anything we like.</p>
<p>let foobar = function (callback) { console.log(“foo”); callback(); console.log(“bar”); };</p>
<p>foobar(function () { console.log(“hello”); }); // prints // foo // hello // bar</p></li>
<li><strong><code>Anonymous Callback</code></strong> : When we use a function expression directly.</li>
<li><p>Typically we want to assign our callback to a name if we plan on using it multiple times, an anonymous callball is better if it’s just single use.</p></li>
</ul>
<p><strong>A More Interesting Example</strong></p>
<pre><code>let add = function (num1, num2, cb) {
    let sum = num1 + num2;
    let result = cb(sum);
    return result;
};

let double = function (num) {
    return num * 2;
};

console.log(add(2, 3, double)); // 10</code></pre>
<ul>
<li><p><strong>Variable expression function</strong> being passed in as an argument.</p>
<p>let add = function (num1, num2, cb) { let sum = num1 + num2; let result = cb(sum); return result; };</p>
<p>console.log(add(60, 4, Math.sqrt)); // 8</p></li>
<li><p><strong><code>Math.sqrt</code></strong> built in function being passed directly in as an argument.</p></li>
</ul>
<p><strong>Refactoring for an Optional Callback</strong></p>
<ul>
<li><p>We can add in a conditional to make the callback optional. (This is a very common pattern in Javascript!)</p>
<p>let add = function (num1, num2, cb) { if (cb === undefined) { return num1 + num2; } else { return cb(num1 + num2); } };</p>
<p>console.log(add(9, 40)); // 49 console.log(add(9, 40, Math.sqrt)); // 7</p></li>
</ul>
<hr />
<h2 id="callback-functions-as-first-class-objects"><strong>Callback Functions as First Class Objects</strong></h2>
<ul>
<li><strong><code>First-Class Object</code></strong> : A type that supports the same basic operations as most other types. (i.e. Numbers, Strings &amp; Booleans)</li>
<li><p>First-Class Objects must be able to do <strong>three things</strong>:</p>
<ul>
<li>They can be stored in variables.
<ul>
<li>Function Expression Notation.</li>
</ul></li>
<li>They can be passed as arguments.
<ul>
<li>Callback Functions.</li>
</ul></li>
<li><p>They can be returned in functions.</p>
<pre><code>function foo() {
    return function () {
        return &quot;I&#39;m a cat&quot;;
    };
}</code></pre></li>
</ul></li>
<li>As we have just proved above, functions are indeed first-class objects!</li>
<li><strong><code>Higher-Order Function</code></strong> : A function that should either accept another function as an argument, or return a function as an output.</li>
<li><p>Callback Functions are passed into Higher-Order Functions.</p></li>
</ul>
<hr />
<h2 id="callback-functions-demo"><strong>Callback Functions Demo</strong></h2>
<p>Interesting Interaction.</p>
<pre><code>let foo = function () {
    let bar = function () {
        console.log(&quot;interesting&quot;);
    };
    return bar;
};

console.log(foo()); // [function: bar]

let res = foo();
console.log(rest); // interesting.</code></pre>
<ul>
<li>Saving our function into a variable will</li>
</ul>
<h1 id="thursday">Thursday ——————————————————————————–</h1>
<h1 id="notes-3"><strong>Notes</strong></h1>
<h2 id="all-about-scope-in-javscript"><strong>All About Scope in Javscript</strong></h2>
<p>The <strong><code>scope</code></strong> of a program in JS is the set of variables that are available for use within the program.</p>
<p><strong>Advantages of utilizing scope</strong></p>
<ul>
<li><strong><code>Security</code></strong> : Adds security by ensuring variables can only be access by pre-defined parts of our program.</li>
<li><strong><code>Reduced Variable Name Collisions</code></strong> : Restricts re-using variable names; helps prevent overwriting variable names.</li>
</ul>
<p><strong>Different Kinds of Scope</strong></p>
<ul>
<li><strong><code>Global Scope</code></strong>
<ul>
<li>The widest and outermost scope.</li>
<li>Represented by the <strong><code>window</code></strong> obj in the browser and the <strong><code>global</code></strong> obj in Node.js.</li>
<li>Try to avoid these as much as possible.</li>
</ul></li>
<li><strong><code>Local Scope</code></strong>
<ul>
<li>Scope within a function.</li>
<li>Includes function arguments, variables declared within function, also <strong>any variables already declared when the function was defined</strong></li>
</ul></li>
<li><strong><code>Block Scope</code></strong>
<ul>
<li>Contents within curly braces.</li>
</ul></li>
</ul>
<p><strong>Scope Chaining: Variables and Scope</strong></p>
<pre><code>let name = &quot;Fiona&quot;;

// we aren&#39;t passing in or defining and variables
function hungryHippo() {
    console.log(name + &quot; is hungry!&quot;);
}

hungryHippo(); // =&gt; &quot;Fiona is hungry&quot;</code></pre>
<ul>
<li>A key scoping rule is that an inner scope <strong>does</strong> have access to variables in the outer scope.</li>
<li><strong><code>Scope Chaining</code></strong> : When a variable is not found within the immediate scope, JS will keep searching outwards until it matches the one we are referencing.</li>
<li>Important to note while inner scopes can search outwards, outer scopes cannot reference inner variables!</li>
</ul>
<p><strong>Lexical Scope</strong></p>
<ul>
<li><p><strong><code>Lexing Time</code></strong> : When you run a piece of JS code that is parsed before it is run.</p></li>
<li><p>JS language does not have dynamic scope.</p></li>
</ul>
<hr />
<h2 id="different-variables-in-javascript"><strong>Different Variables in Javascript</strong></h2>
<ul>
<li><em>A variable always evaluates to the value it contains no matter how you declare it.</em></li>
</ul>
<p><strong>The different ways to declare variables</strong></p>
<ul>
<li><strong><code>let</code></strong> : can be re-assigned; block-scoped.</li>
<li><strong><code>const</code></strong> : no re-assignment; block scoped.</li>
<li><strong><code>var</code></strong> : May or may not be re-assigned; scoped to a function.</li>
</ul>
<p><strong>Hoisting and Scoping with Variables</strong></p>
<p><strong><code>Hoisting</code></strong> is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</p>
<p><strong>Function-Scoped Variables</strong></p>
<ul>
<li>As we learned, var creates function-scoped variables, this means our declared var keyword variable will be confined to the scope of our current function.</li>
</ul>
<p><strong>Hoisting with function-scoped variables</strong></p>
<pre><code>function test() {
    // var hoistedVar;
    console.log(hoistedVar); // =&gt;  undefined
    var hoistedVar = 10;
}</code></pre>
<ul>
<li>Even though we initially declared &amp; initizalized our variable underneath the console.log var variables are “hoisted” to the top, but only in declaration.</li>
</ul>
<p><strong>Block-Scoped Variables</strong></p>
<p>Things that create block-scopes:</p>
<ul>
<li>If Statements</li>
<li>While Loops</li>
<li>Switch Statements</li>
<li>For Loops</li>
</ul>
<p><strong>Properties of Constants</strong></p>
<ul>
<li>They are block-scoped like let.</li>
<li>JS will enforce constants by raising an error if you try to change them.</li>
<li>Constants that are assigned to Reference Types are <strong>mutable</strong></li>
</ul>
<p><strong>Hoisting with block-scoped variables</strong></p>
<ul>
<li>Unlike vars in function scopes, let and const in their block scopes do not get their declarations hoisted.</li>
<li>Instead they are not initalized until their definitions are evaluated - instead of undefined we will get an error.</li>
<li><strong><code>Temporal Dead Zone</code></strong> : The time before a let or const variable is declared.</li>
</ul>
<p><strong>Function Scope vs Block Scope</strong></p>
<ul>
<li>The downside of the flexibility of var is that it can easily overwrite previously declared variables.</li>
<li>The block-scope limitations of let and const were introduced to easily avoid accidentally overwriting variable values.</li>
</ul>
<p><strong>Global Variables</strong></p>
<ul>
<li>Any variables declared without a declaration term will be considered <strong><code>global scope</code></strong>.</li>
<li>Every time a variable is declared on the global scope, the change of collision increases.</li>
<li>Use the proper declarations to manage your code: Avoid being a sloppy programmer!</li>
</ul>
<hr />
<h2 id="closures"><strong>Closures</strong></h2>
<p><strong>Calculating Closures</strong></p>
<ul>
<li><strong>Closure</strong> : The combination of a function and the lexical environment within which that function is declared.</li>
<li><strong>Use</strong> : A closure is when an inner function uses, or changes, variables in an outer function.</li>
<li>Very important for creativity, flexibility, and security of your code.</li>
<li><strong><code>Lexical Environment</code></strong> : Consists of any variables available within the scope in which a closure was declared (local inner, outer, and global).</li>
</ul>
<p><strong>Closures and Scope</strong> Basic Closure Rules:</p>
<ul>
<li>Closures have access to all variables in it’s lexical environment.</li>
<li>A closure will keep reference to all the variables when it was defined <strong>even if the outer function has returned</strong>.</li>
</ul>
<p><strong>Applications of Closures</strong></p>
<ul>
<li><strong>Private State</strong>
<ul>
<li>JS does not have a way of declaring a function as exclusively private, however we can use closures to make a private state.</li>
</ul></li>
<li><p><strong>Passing Arguments Implicitly</strong></p>
<ul>
<li><p>We can use closures to pass down arguments to helper functions.</p>
<p>function isPalindrome(string) { function reverse() { return string.split("“).reverse().join(”"); }</p>
<p>return string === reverse(); }</p></li>
</ul></li>
</ul>
<hr />
<h2 id="context-in-javascript"><strong>Context in Javascript</strong></h2>
<ul>
<li><strong><code>Scope</code></strong> : Refers to the visibility and availability of variables.</li>
<li><strong><code>Context</code></strong> : Refers to the value of the <strong><code>this</code></strong> keyword when code is executed.</li>
</ul>
<p><strong>What about <code>this</code> ?</strong></p>
<ul>
<li><strong><code>This</code></strong> : Keyword that exists in every function and evaluates to the object that is currently invoking that function.</li>
<li><strong>Method-Style Invocation</strong> : syntax goes like <code>object.method(arg)</code>. (i.e. array.push, str.toUpperCase()</li>
<li><strong><code>Context</code></strong> refers to the value of this within a function and <strong><code>this</code></strong> refers to where a function is invoked.</li>
</ul>
<p><strong>Issues with Scope and Context</strong></p>
<ul>
<li>If <code>this</code> is called using normal function style invocation, our output will be the contents of the global object.</li>
</ul>
<p><strong>When Methods have an Unexpected Context</strong></p>
<pre><code>let dog = {
    name: &quot;Bowser&quot;,
    changeName: function () {
        this.name = &quot;Layla&quot;;
    },
};

let change = dog.changeName;
console.log(change()); // undefined

console.log(dog); // { name: &#39;Bowser&#39;, changeName: [Function: changeName] }

console.log(this); // Object [global] {etc, etc, etc,  name: &#39;Layla&#39;}</code></pre>
<ul>
<li>In the above example we get undefined when we assign our this function to a variable bc there is no obj to reference except the global one!</li>
<li><p><strong><code>global.setTimeout()</code></strong> : popular method of setting a function to run on a timer.</p>
<ul>
<li><p>Accepts a callback and a number of milliseconds to wait before invoking the callback.</p>
<pre><code>```js
let hello = function () {
  console.log(&quot;hello!&quot;);
};

// global. is a method of the global object!
global.setTimeout(hello, 5000); // waits 5 seconds then prints &quot;hello!&quot;
```</code></pre></li>
</ul></li>
</ul>
<p><strong>Strictly Protecting the Global Object</strong></p>
<p>We can run JS in strict mode by tagging <code>use strict</code> at the top of our program.</p>
<ul>
<li>If we try to invoke this on our global function in strict mode we will no longer be able to access it and instead just get undefined.</li>
</ul>
<p><strong>Changing Context using Bind</strong></p>
<p>“The simplest use of <strong><code>bind()</code></strong> is to make a function that, no matter how it is called, is called with a particular this value”.</p>
<pre><code>let cat = {
    purr: function () {
        console.log(&quot;meow&quot;);
    },
    purrMore: function () {
        this.purr();
    },
};

let sayMeow = cat.purrMore;
console.log(sayMeow()); // TypeError

let boundCat = sayMeow.bind(cat);

boundCat(); // prints &quot;meow&quot;</code></pre>
<p><strong>Binding with Arguments</strong></p>
<ul>
<li><p>We can also use bind() to bind arguments to a function.</p>
<pre><code>let aboundFunc = func.bind(context, arg1, arg2, etc...);

const sum = function (a, b) {
  return a + b;
};

const add3 = sum.bind(null, 3);

console.log(add3(10)); // 13

const multiply = function (a, b) {
  return a * b;
};

const double = multiply.bind(null, 2);
const triple = multiply.bind(null, 3);

console.log(double(3)); // 6
console.log(triple(3)); // 9</code></pre></li>
</ul>
<hr />
<h2 id="arrow-functions-aka-fat-arrows"><strong>Arrow Functions aka Fat Arrows</strong></h2>
<ul>
<li><strong><code>=&gt;</code></strong> : A more concise way of declaring a function and also considers the behavior of <code>this</code> and context.</li>
</ul>
<p><strong>Arrow Functions Solving Problems</strong></p>
<pre><code>let average = function (num1, num2) {
    let avg = (num1 + num2) / 2;
    return avg;
};

let averageArrow = (num1, num2) =&gt; {
    let avg = (num1 + num2) / 2;
    return avg;
};</code></pre>
<p>As you can see the arrow function is shorter and easier to read.</p>
<p><strong>Anatomy of an Arrow Function</strong></p>
<ul>
<li>If there is only a single parameter there is no need to add parenthesis before the arrow function.</li>
<li>However if there are zero parameters then you must add an empty set of parentheses.</li>
</ul>
<p><strong>Single Expression Arrow Functions</strong></p>
<ul>
<li>Arrow functions, <em>unlike</em> normal functions, carry over context, binding <code>this</code> lexically.</li>
<li>Value of <code>this</code> inside an arrow function is not dependent on how it is invoked.</li>
<li>Because arrow functions already have a <em>bound context</em>, you can’t reassign <code>this</code>.</li>
</ul>
<hr />
</body>
</html>
