<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Notes</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="notes"><strong>Notes</strong></h1>
<h2 id="all-about-scope-in-javscript"><strong>All About Scope in Javscript</strong></h2>
<p>The <strong><code>scope</code></strong> of a program in JS is the set of variables that are available for use within the program.</p>
<p><strong>Advantages of utilizing scope</strong></p>
<ul>
<li><strong><code>Security</code></strong> : Adds security by ensuring variables can only be access by pre-defined parts of our program.</li>
<li><strong><code>Reduced Variable Name Collisions</code></strong> : Restricts re-using variable names; helps prevent overwriting variable names.</li>
</ul>
<p><strong>Different Kinds of Scope</strong></p>
<ul>
<li><strong><code>Global Scope</code></strong>
<ul>
<li>The widest and outermost scope.</li>
<li>Represented by the <strong><code>window</code></strong> obj in the browser and the <strong><code>global</code></strong> obj in Node.js.</li>
<li>Try to avoid these as much as possible.</li>
</ul></li>
<li><strong><code>Local Scope</code></strong>
<ul>
<li>Scope within a function.</li>
<li>Includes function arguments, variables declared within function, also <strong>any variables already declared when the function was defined</strong></li>
</ul></li>
<li><strong><code>Block Scope</code></strong>
<ul>
<li>Contents within curly braces.</li>
</ul></li>
</ul>
<p><strong>Scope Chaining: Variables and Scope</strong></p>
<pre><code>let name = &quot;Fiona&quot;;

// we aren&#39;t passing in or defining and variables
function hungryHippo() {
  console.log(name + &quot; is hungry!&quot;);
}

hungryHippo(); // =&gt; &quot;Fiona is hungry&quot;</code></pre>
<ul>
<li>A key scoping rule is that an inner scope <strong>does</strong> have access to variables in the outer scope.</li>
<li><strong><code>Scope Chaining</code></strong> : When a variable is not found within the immediate scope, JS will keep searching outwards until it matches the one we are referencing.</li>
<li>Important to note while inner scopes can search outwards, outer scopes cannot reference inner variables!</li>
</ul>
<p><strong>Lexical Scope</strong></p>
<ul>
<li><p><strong><code>Lexing Time</code></strong> : When you run a piece of JS code that is parsed before it is run.</p></li>
<li><p>JS language does not have dynamic scope.</p></li>
</ul>
<hr />
<h2 id="different-variables-in-javascript"><strong>Different Variables in Javascript</strong></h2>
<ul>
<li><em>A variable always evaluates to the value it contains no matter how you declare it.</em></li>
</ul>
<p><strong>The different ways to declare variables</strong></p>
<ul>
<li><strong><code>let</code></strong> : can be re-assigned; block-scoped.</li>
<li><strong><code>const</code></strong> : no re-assignment; block scoped.</li>
<li><strong><code>var</code></strong> : May or may not be re-assigned; scoped to a function.</li>
</ul>
<p><strong>Hoisting and Scoping with Variables</strong></p>
<p><strong><code>Hoisting</code></strong> is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</p>
<p><strong>Function-Scoped Variables</strong></p>
<ul>
<li>As we learned, var creates function-scoped variables, this means our declared var keyword variable will be confined to the scope of our current function.</li>
</ul>
<p><strong>Hoisting with function-scoped variables</strong></p>
<pre><code>function test() {
  // var hoistedVar;
  console.log(hoistedVar); // =&gt;  undefined
  var hoistedVar = 10;
}</code></pre>
<ul>
<li>Even though we initially declared &amp; initizalized our variable underneath the console.log var variables are “hoisted” to the top, but only in declaration.</li>
</ul>
<p><strong>Block-Scoped Variables</strong></p>
<p>Things that create block-scopes:</p>
<ul>
<li>If Statements</li>
<li>While Loops</li>
<li>Switch Statements</li>
<li>For Loops</li>
</ul>
<p><strong>Properties of Constants</strong></p>
<ul>
<li>They are block-scoped like let.</li>
<li>JS will enforce constants by raising an error if you try to change them.</li>
<li>Constants that are assigned to Reference Types are <strong>mutable</strong></li>
</ul>
<p><strong>Hoisting with block-scoped variables</strong></p>
<ul>
<li>Unlike vars in function scopes, let and const in their block scopes do not get their declarations hoisted.</li>
<li>Instead they are not initalized until their definitions are evaluated - instead of undefined we will get an error.</li>
<li><strong><code>Temporal Dead Zone</code></strong> : The time before a let or const variable is declared.</li>
</ul>
<p><strong>Function Scope vs Block Scope</strong></p>
<ul>
<li>The downside of the flexibility of var is that it can easily overwrite previously declared variables.</li>
<li>The block-scope limitations of let and const were introduced to easily avoid accidentally overwriting variable values.</li>
</ul>
<p><strong>Global Variables</strong></p>
<ul>
<li>Any variables declared without a declaration term will be considered <strong><code>global scope</code></strong>.</li>
<li>Every time a variable is declared on the global scope, the change of collision increases.</li>
<li>Use the proper declarations to manage your code: Avoid being a sloppy programmer!</li>
</ul>
<hr />
<h2 id="closures"><strong>Closures</strong></h2>
<p><strong>Calculating Closures</strong></p>
<ul>
<li><strong>Closure</strong> : The combination of a function and the lexical environment within which that function is declared.</li>
<li><strong>Use</strong> : A closure is when an inner function uses, or changes, variables in an outer function.</li>
<li>Very important for creativity, flexibility, and security of your code.</li>
<li><strong><code>Lexical Environment</code></strong> : Consists of any variables available within the scope in which a closure was declared (local inner, outer, and global).</li>
</ul>
<p><strong>Closures and Scope</strong> Basic Closure Rules:</p>
<ul>
<li>Closures have access to all variables in it’s lexical environment.</li>
<li>A closure will keep reference to all the variables when it was defined <strong>even if the outer function has returned</strong>.</li>
</ul>
<p><strong>Applications of Closures</strong></p>
<ul>
<li><strong>Private State</strong>
<ul>
<li>JS does not have a way of declaring a function as exclusively private, however we can use closures to make a private state.</li>
</ul></li>
<li><p><strong>Passing Arguments Implicitly</strong></p>
<ul>
<li><p>We can use closures to pass down arguments to helper functions.</p>
<p>function isPalindrome(string) { function reverse() { return string.split(““).reverse().join(”"); }</p>
<p>return string === reverse(); }</p></li>
</ul></li>
</ul>
<hr />
<h2 id="context-in-javascript"><strong>Context in Javascript</strong></h2>
<ul>
<li><strong><code>Scope</code></strong> : Refers to the visibility and availability of variables.</li>
<li><strong><code>Context</code></strong> : Refers to the value of the <strong><code>this</code></strong> keyword when code is executed.</li>
</ul>
<p><strong>What about <code>this</code> ?</strong></p>
<ul>
<li><strong><code>This</code></strong> : Keyword that exists in every function and evaluates to the object that is currently invoking that function.</li>
<li><strong>Method-Style Invocation</strong> : syntax goes like <code>object.method(arg)</code>. (i.e. array.push, str.toUpperCase()</li>
<li><strong><code>Context</code></strong> refers to the value of this within a function and <strong><code>this</code></strong> refers to where a function is invoked.</li>
</ul>
<p><strong>Issues with Scope and Context</strong></p>
<ul>
<li>If <code>this</code> is called using normal function style invocation, our output will be the contents of the global object.</li>
</ul>
<p><strong>When Methods have an Unexpected Context</strong></p>
<pre><code>let dog = {
  name: &quot;Bowser&quot;,
  changeName: function () {
    this.name = &quot;Layla&quot;;
  },
};

let change = dog.changeName;
console.log(change()); // undefined

console.log(dog); // { name: &#39;Bowser&#39;, changeName: [Function: changeName] }

console.log(this); // Object [global] {etc, etc, etc,  name: &#39;Layla&#39;}</code></pre>
<ul>
<li>In the above example we get undefined when we assign our this function to a variable bc there is no obj to reference except the global one!</li>
<li><p><strong><code>global.setTimeout()</code></strong> : popular method of setting a function to run on a timer.</p>
<ul>
<li><p>Accepts a callback and a number of milliseconds to wait before invoking the callback.</p>
<pre><code>```js
let hello = function () {
  console.log(&quot;hello!&quot;);
};

// global. is a method of the global object!
global.setTimeout(hello, 5000); // waits 5 seconds then prints &quot;hello!&quot;
```</code></pre></li>
</ul></li>
</ul>
<p><strong>Strictly Protecting the Global Object</strong></p>
<p>We can run JS in strict mode by tagging <code>use strict</code> at the top of our program.</p>
<ul>
<li>If we try to invoke this on our global function in strict mode we will no longer be able to access it and instead just get undefined.</li>
</ul>
<p><strong>Changing Context using Bind</strong></p>
<p>“The simplest use of <strong><code>bind()</code></strong> is to make a function that, no matter how it is called, is called with a particular this value”.</p>
<pre><code>let cat = {
  purr: function () {
    console.log(&quot;meow&quot;);
  },
  purrMore: function () {
    this.purr();
  },
};

let sayMeow = cat.purrMore;
console.log(sayMeow()); // TypeError

let boundCat = sayMeow.bind(cat);

boundCat(); // prints &quot;meow&quot;</code></pre>
<p><strong>Binding with Arguments</strong></p>
<ul>
<li><p>We can also use bind() to bind arguments to a function.</p>
<pre><code>let aboundFunc = func.bind(context, arg1, arg2, etc...);

const sum = function (a, b) {
  return a + b;
};

const add3 = sum.bind(null, 3);

console.log(add3(10)); // 13

const multiply = function (a, b) {
  return a * b;
};

const double = multiply.bind(null, 2);
const triple = multiply.bind(null, 3);

console.log(double(3)); // 6
console.log(triple(3)); // 9</code></pre></li>
</ul>
<hr />
<h2 id="arrow-functions-aka-fat-arrows"><strong>Arrow Functions aka Fat Arrows</strong></h2>
<ul>
<li><strong><code>=&gt;</code></strong> : A more concise way of declaring a function and also considers the behavior of <code>this</code> and context.</li>
</ul>
<p><strong>Arrow Functions Solving Problems</strong></p>
<pre><code>let average = function (num1, num2) {
  let avg = (num1 + num2) / 2;
  return avg;
};

let averageArrow = (num1, num2) =&gt; {
  let avg = (num1 + num2) / 2;
  return avg;
};</code></pre>
<p>As you can see the arrow function is shorter and easier to read.</p>
<p><strong>Anatomy of an Arrow Function</strong></p>
<ul>
<li>If there is only a single parameter there is no need to add parenthesis before the arrow function.</li>
<li>However if there are zero parameters then you must add an empty set of parentheses.</li>
</ul>
<p><strong>Single Expression Arrow Functions</strong></p>
<ul>
<li>Arrow functions, <em>unlike</em> normal functions, carry over context, binding <code>this</code> lexically.</li>
<li>Value of <code>this</code> inside an arrow function is not dependent on how it is invoked.</li>
<li>Because arrow functions already have a <em>bound context</em>, you can’t reassign <code>this</code>.</li>
</ul>
<hr />
</body>
</html>
