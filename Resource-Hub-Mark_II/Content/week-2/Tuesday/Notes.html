<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Notes</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="notes"><strong>Notes</strong></h1>
<h2 id="the-object-type"><strong>The Object Type</strong></h2>
<p>The <strong><code>object</code></strong> is a data structure that stores other data, similar to how an array stores elements.</p>
<ul>
<li>The object differs in that each <strong><code>value</code></strong> stores in an obj is associated with a <strong><code>key</code></strong>.</li>
</ul>
<p><strong>The Object of My Affections</strong></p>
<p>In other programming languages, objects are referred to as, “dictionaries”, “maps”, or “associative arrays”.</p>
<ul>
<li>Objects are indexed with <strong><code>keys</code></strong> instead of numbers.</li>
<li>Order is not guaranteed within an Object.</li>
<li>Objects are defined by using curly braces <strong><code>{}</code></strong></li>
<li>You can think of Objects as tables.</li>
</ul>
<blockquote>
<p>Fun Fact: Objects are affectionately known as POJO’s (Plain Old Javascript Objects)</p>
</blockquote>
<p><strong>Setting Keys and Values</strong></p>
<pre><code>// here &quot;color&quot; is the key!
&gt; car[&quot;color&quot;] = &quot;Blue&quot;;
&quot;Blue&quot;

&gt; car[&quot;seats&quot;] = 2;
2

// accessing our object at the key of color
&gt; car[&quot;color&quot;]
&quot;Blue&quot;

&gt; car[&quot;seats&quot;]
2

&gt; car
{color: &quot;Blue&quot;, seats: 2}</code></pre>
<ul>
<li><p>We assign values to an object by defining the name of the key in brackets and assigning it to a value.</p>
<blockquote>
<p>car {color: “Blue”, seats: 2}</p>
</blockquote>
<blockquote>
<p>“color” in car; true</p>
</blockquote>
<blockquote>
<p>“model” in car; false</p>
</blockquote></li>
<li>If we try to access a key that has not yet been assigned within an object we will output undefined.</li>
<li><p>The <strong>preferred method</strong> for checking to see if an object exists at a key is to use the <strong><code>in</code></strong> operator.</p></li>
</ul>
<p><strong>Using Variables as Keys</strong></p>
<pre><code>&gt; car
{color: &quot;Blue&quot;, seats: 2}

&gt; let newVariable = &quot;color&quot;;
undefined

&gt; newVariable
&quot;color&quot;

&gt; car[newVariable]
&quot;Blue&quot;

---

&gt; car
{color: &quot;Blue&quot;, seats: 2}

&gt; newVariable
&quot;weight&quot;

// assigning a key value pair using a variable!
&gt; car[newVariable] = 1000;
1000

&gt; car
{color: &quot;Blue&quot;, seats: 2, weight: 1000}</code></pre>
<ul>
<li>It is useful to set a variable as a key, because variables can be re-assigned new values - this way we can quickly access different data and also create new key/value pairs.</li>
</ul>
<h2 id="using-different-notations"><strong>Using Different Notations</strong></h2>
<pre><code>&gt; let dog = {};
undefined

&gt; dog.bark = &quot;Bowowowo&quot;;
&quot;Bowowowowo&quot;

&gt; dog.bark
&quot;Bowowowo&quot;

&gt; dog
{ bark: &quot;Bowowowowo&quot; }</code></pre>
<ul>
<li>We can also use <strong>dot notation</strong> <strong>“.”</strong> to access key/value pairs in an object.
<ul>
<li>One thing to note is that when using dot notation, we do not have to use string quotes as the key.</li>
</ul></li>
</ul>
<p><strong>Bracket Notation vs Dot Notation</strong></p>
<table style="width:99%;">
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>
<strong>Dot</strong>
</th>
<th>
<strong>Bracket</strong>
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
Easier To Read
</td>
<td>
You can use variables as keys!
</td>
</tr>
<tr class="even">
<td>
Easier To Write b/c do not need Quotations.
</td>
<td>
Okay to use variables and Strings that start with numbers.
</td>
</tr>
<tr class="odd">
<td>
Cannot access with Variables
</td>
<td>
</td>
</tr>
<tr class="even">
<td>
Keys cannot contain numbers as their first character
</td>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>When accessing object keys</strong>: Bracket notation needs to refer to that key in quotations, dot notation doesn’t.</li>
<li><p><strong>When accessing object keys via a variable</strong>: Bracket notation can refer to that key w/o use of quotations, dot notation can’t do this at all.</p>
<p>let myDog = {}; myDog.name = “Fido”;</p>
<p>let myKey = “name”; console.log(myDog); // prints <code>{name: "Fido"}</code> console.log(myDog[myKey]); // prints <code>Fido</code></p>
<p>console.log(myDog.myKey); // prints: undefined</p></li>
<li><p>As illustrated above, the dot notation cannot access a varible key - since it takes a <strong>literal</strong> interpretation of the key.</p></li>
</ul>
<p><strong>Putting it All Together</strong></p>
<p>You can put an object together in a single statement.</p>
<pre><code>let myDog = {
  name: &quot;Fido&quot;,
  type: &quot;Doge&quot;,
  age: 2,
  favoriteToys: [&quot;bone&quot;, &quot;ball&quot;],
};</code></pre>
<p><strong>Operator Precedence Revisited</strong></p>
<ul>
<li>The concept of Operator Precedence also applies to objects.</li>
<li>There are two types of associativity:
<ul>
<li><p><strong><code>Right Associativity</code></strong> : When code is evaluted right to left.</p>
<pre><code>a = b = 1;</code></pre>
<ul>
<li>Since <strong>assignment of variables</strong> takes lowest precendence, we end up evaluating b = 1 first before a = b.</li>
</ul></li>
<li><p><strong><code>Left Associativity</code></strong> : When code is evaluated left to right.</p>
<pre><code>let id = &quot;header&quot;;
let element = document.getElementById(id).value;</code></pre>
<ul>
<li>We first resolve the document variable, then use dot notation to retrive the getElementById function, we eval it’s arguments, access it’s value, and then retrieve assignment (the lowest precedence).</li>
</ul></li>
</ul></li>
</ul>
<hr />
<h2 id="iterating-through-objects"><strong>Iterating Through Objects</strong></h2>
<p>Because objects store <strong><em>unordered</em></strong> key-value pairs, we do not rely on indices to access values; instead we rely on our keys.</p>
<p><strong>A New Kind of For Loop</strong></p>
<pre><code>for (let variable in object) {
  statement;

  let obj = { name: &quot;Rose&quot;, cats: 2 };
  for (let currentKey in obj) {
    console.log(currentKey);
    console.log(obj[currentKey]);
  }

  // prints out:
  // name
  // cats
  // Rose
  // 2
}</code></pre>
<ul>
<li>We use a special syntax to iterate through each key of an object called a <strong><code>for-in loop</code></strong>.</li>
</ul>
<p><strong>Methods vs Functions</strong></p>
<p>A <strong><code>Method</code></strong> is a function that <em>belongs</em> to an object. Every method is a function, but <em>not</em> every function is a method.</p>
<pre><code>myFunc is a function
myObject.myFunc is a method of the object myObject
myObject[&quot;myFunc&quot;] is a method of the object myObject</code></pre>
<ul>
<li><p><strong>Methods</strong> are just a key-value pair where the <strong>key is the function name and the value is the function definition</strong>.</p>
<p>let dog = { name: “Fido”, };</p>
<p>dog.bark = function () { console.log(“bark bark!”); };</p>
<p>// this is the same thing as above just using Bracket Notation dog[“speak”] = function (string) { console.log(“WOOF” + string + " WOOF!!!"); };</p>
<p>dog.bark(); // prints <code>bark bark!</code> dog.speak(“pizza”); // prints <code>WOOF pizza WOOF!!!</code></p>
<p>let dog2 = { name: “Rover”,</p>
<p>bark: function () { console.log(“bork bork!”); },</p>
<p>speak: function (string) { console.log(“BORK” + string + " BORK!!!"); }, }; // Notice that in the object above, we still separate the key-value pairs with commas. // <code>bark</code> and <code>speak</code> are just keys with functions as values.</p>
<p>dog2.bark(); // prints <code>bork bork!</code> dog2.speak(“burrito”); // prints <code>BORK burrito BORK!!!</code></p></li>
<li><p>To invoke these methods we just need to specify which object is calling that method.</p>
<p>myObject.methodName();</p></li>
</ul>
<p><strong>Useful Object Methods</strong></p>
<ul>
<li><strong><code>Object.keys()</code></strong> : A method that allows us to iterate through keys, it accepts an obj as the argument and returns an array of the keys.</li>
<li><strong><code>Object.values()</code></strong> : Method that accepts an object as the argument and returns an array of the values.</li>
</ul>
<p><strong>Iterating through an Object’s keys &amp; values</strong></p>
<ul>
<li><p><strong><code>Object.entries</code></strong> : Method that accepts an object as the argument and returns an array of the [key,value] pairs within.</p>
<blockquote>
<p>Object.entries(cat) [ [ ‘name’, ‘Freyja’ ], [ ‘color’, ‘orange’ ] ]</p>
</blockquote></li>
</ul>
<hr />
<h2 id="references-vs-primitives"><strong>References vs Primitives</strong></h2>
<p><strong>Primitives vs Objects</strong></p>
<p>So far we have learned about 6 different data types:</p>
<ul>
<li><strong>Primitive</strong> : Boolean, Null, Undefined, Number, String.</li>
<li><strong>Reference</strong> : Object (Arrays are a type of object)</li>
<li>Remember that <strong>primitive</strong> types are immutable!</li>
</ul>
<p><strong>Immutabiity</strong></p>
<figure>
<img src="https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-JavaScript/pojo/assets/assignment-num2.png" alt="pic of nums" /><figcaption>pic of nums</figcaption>
</figure>
<ul>
<li>When we reassign primitives we simply have our variable point elsewhere in memory.</li>
<li>In a nutshell, <strong>immutability</strong> cannot change values in memory, but only reassign where our variables are pointing to.</li>
</ul>
<p><strong>Mutabulity</strong></p>
<figure>
<img src="https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-JavaScript/pojo/assets/assignment-num5.png" alt="img of mut" /><figcaption>img of mut</figcaption>
</figure>
<ul>
<li>If we change either cat1 or cat2, our computer memory will change because they are both pointing at the same memory location.</li>
</ul>
<hr />
<h2 id="rest-and-spread"><strong>Rest and Spread</strong></h2>
<p><strong>Using the Spread Operator and Rest Parameter Syntax</strong> <strong>Accepting Arguments</strong></p>
<ul>
<li>Just keep in mind that function will still run even if it is not passed any arguments.</li>
<li>Parameters will take just as many arguments they need even if more than enough are offered.</li>
<li>We will encounter an error if there are not enough parameters ( &gt; 0).</li>
</ul>
<p><strong>Utilizing Rest Parameters</strong></p>
<ul>
<li><strong><code>Rest Parameter Syntax</code></strong> : Allows us to capture all of a function’s incoming arguments into an array.</li>
<li>Only the last parameter can be a rest parameter.</li>
</ul>
<p><strong>Utilizing Spread Syntax</strong></p>
<ul>
<li><strong>Spread Operator</strong> : Allows us to break down a data type into the elements that make it up.
<ul>
<li>Takes a data type (i.e. array, obj) and spreads the values of that type where elements are expected.</li>
<li>Takes iterable data and spreads the elements of that type where arguments are expected.</li>
</ul>
<p>let numArray = [1, 2, 3];</p>
<p>// here we are taking <code>numArray</code> and <em>spreading</em> it into a new array where // comma separated elements are expected to be let moreNums = […numArray, 4, 5, 6];</p>
<blockquote>
<p>moreNums // =&gt; [1, 2, 3, 4, 5, 6]</p>
</blockquote></li>
</ul>
<p><strong>With Objects</strong></p>
<pre><code>let colors = { red: &quot;scarlet&quot;, blue: &quot;aquamarine&quot; };
let newColors = { ...colors };

&gt; newColors
// { red: &quot;scarlet&quot;, blue: &quot;aquamarine&quot; };

let colors = { red: &quot;scarlet&quot;, blue: &quot;aquamarine&quot; };
let colors2 = { green: &quot;forest&quot;, yellow: &quot;sunflower&quot; };

let moreColors = { ...colors, ...colors2 };

&gt; moreColors
// {red: &quot;scarlet&quot;, blue: &quot;aquamarine&quot;, green: &quot;forest&quot;, yellow: &quot;sunflo</code></pre>
<p><strong>Spreading Arguments</strong></p>
<pre><code>function speak(verb, noun) {
  return &quot;I like to go &quot; + verb + &quot; with &quot; + noun + &quot;.&quot;;
}

const words = [&quot;running&quot;, &quot;Jet&quot;];

console.log(speak(&quot;running&quot;, &quot;Jet&quot;)); // =&gt; I like to go running with Jet.
console.log(speak(...words)); // =&gt; I like to go running with Jet.</code></pre>
<hr />
<h2 id="destructuring"><strong>Destructuring</strong></h2>
<ul>
<li><p><strong><code>Destructuring Syntax</code></strong> : Allows you to extract parts of an array or obj intro distinct variables.</p>
<p>let numArray = [10, 20];</p>
<p>// here we are “unpacking” the array values into two separate variables let [firstEl, secondEl] = numArray;</p>
<p>console.log(firstEl); //=&gt; 10 console.log(secondEl); //=&gt; 20</p></li>
</ul>
<p><strong>Swapping Variables using destructuring</strong></p>
<pre><code>let num1 = 17;
let num2 = 3;

// this syntax will swap the values of the two variables
[num1, num2] = [num2, num1];

console.log(num1); // 3
console.log(num2); // 17</code></pre>
<ul>
<li>One of the cool things we can do with destructuring is swap the values of two variables.</li>
</ul>
<p><strong>Destructuring objects into variables</strong></p>
<ul>
<li><p>One of the most useful parts of destructuring is the ability to take apart and assign little slices of large objs to variables.</p>
<p>let obj = { name: “Apples”, breed: [“tabby”, “short hair”] }; let { name, breed } = obj;</p>
<p>console.log(name); // “Apples” console.log(breed); // [“tabby”, “short hair”]</p></li>
<li><p><strong>Aliased Object Destructuring</strong> : When our variable does not have the same name as our object’s keys.</p>
<p>let obj = { apple: “red”, banana: “yellow” }; let { apple: newApple, banana: newBanana } = obj;</p>
<p>console.log(newApple); // “red” console.log(newBanana); // “yellow”</p></li>
<li><p>Good rule of thumb to keep clarity in your code is to only destructure values from objects that are two levels deep.</p>
<p>// the fname key is nested more than two levels deep // (within bootcamp.instructor.fullName) let bootcamp = { name: “App Academy”, color: “red”, instructor: { fullName: { fname: “Rose”, lname: “K”, }, }, };</p>
<p>// this is hard to follow: let { instructor: { fullName: { fname, lname }, }, } = bootcamp; console.log(fname, lname);</p>
<p>// this is much easier to read: let { fname, lname } = bootcamp.instructor.fullName; console.log(fname, lname);</p></li>
</ul>
<p><strong>Destructuring and the Rest Pattern</strong></p>
<pre><code>let foods = [&quot;pizza&quot;, &quot;ramen&quot;, &quot;sushi&quot;, &quot;kale&quot;, &quot;tacos&quot;];

let [firstFood, secondFood, ...otherFoods] = foods;
console.log(firstFood); // =&gt; &quot;pizza&quot;
console.log(secondFood); // =&gt; &quot;ramen&quot;
console.log(otherFoods); // =&gt; [&quot;sushi&quot;, &quot;kale&quot;, &quot;tacos&quot;]</code></pre>
<ul>
<li><p>Currently the rest pattern is only officially supported by JS when destructuring arrays.</p>
<p>let { a, c, …obj } = { a: 1, b: 2, c: 3, d: 4 }; console.log(a); // =&gt; 1 console.log(c); // =&gt; 3 console.log(obj); // =&gt; { b: 2, d: 4 }</p></li>
</ul>
<hr />
<h2 id="destructuring-parameters"><strong>Destructuring Parameters</strong></h2>
<p>We can also destructure <strong>incoming parameters</strong> of a function. This is very useful when we’re passing objects around to different functions.</p>
<pre><code>let cat = { name: &quot;Rupert&quot;, owner: &quot;Curtis&quot;, weight: 10 };

// This unpacks the *owner* key out of any incoming object argument and
// assigns it to a owner parameter(variable)
function ownerName({ owner }) {
  console.log(&quot;This cat is owned by &quot; + owner);
}

ownerName(cat);

let bigCat = {
  name: &quot;Jet&quot;,
  owner: { name: &quot;Rose&quot; },
  toys: [&quot;ribbon&quot;],
  siblings: { name: &quot;Freyja&quot;, color: &quot;orange&quot;, toys: [&quot;mouse&quot;, &quot;string&quot;] },
};

// here we use *aliased* object destructuring to create a siblingToys variable
function toyFinder({ toys, siblings: { toys: siblingToys } }) {
  let allToys = toys.concat(siblingToys);
  return allToys;
}

console.log(toyFinder(bigCat)); // =&gt; [&quot;ribbon&quot;, &quot;mouse&quot;, &quot;string&quot;]</code></pre>
<hr />
<h2 id="benefits-of-pair-programming"><strong>Benefits of Pair Programming</strong></h2>
<p><strong>Benefits of Pair Programming</strong></p>
<ul>
<li><p>Prevents focusing so much on a problem that you forget to communicate with your teammates.</p></li>
<li><p>Helps us share knowledge faster.</p></li>
</ul>
<blockquote>
<p>Variations of Pair Programming include Mob Programming (3+), and Extreme Programming (Entire Team Rotates through Projects), all of these are known as <em>Collaborative Programming</em>.</p>
</blockquote>
<p><strong>Common Concepts</strong></p>
<ul>
<li>One Shared Device for Coding.</li>
<li>Everyone has a job.</li>
<li>Everyone gets a turn.</li>
<li>No one is “too good to pair” - it’s a team process!</li>
</ul>
<p><strong>Pair Programming Roles</strong></p>
<ul>
<li><strong><code>The Driver</code></strong> : In charge of typing and asking questions, can let go or larger picture. Driver also suggests ways to improve/re-factor the code.</li>
<li><strong><code>The Navigator</code></strong> : In charge of what’s being typed and maintaining project momentum. They should lead the discussion and also double check the code for errors as it is being typed.</li>
</ul>
<p><strong>Shared Responsibilities</strong></p>
<ul>
<li>Both need to discuss the plan, and often.</li>
<li>As Navigator leads, the Driver should constantly second-guess.</li>
<li>It is okay for the driver to bring up a problem!</li>
</ul>
<p><strong>Why Pair Up?</strong></p>
<ul>
<li>Statistics have shown that pair programming slow down programming time by 15% <em>however</em> it also reflected that the number of errors are also reduced by 15%.</li>
</ul>
<hr />
<h2 id="app-academy-pair-programming-approach"><strong>App Academy Pair Programming Approach</strong></h2>
<p><strong>A 5-Step Process</strong></p>
<ul>
<li><strong><code>Partner Up</code></strong> : Get your pal.</li>
<li><strong><code>Check-In</code></strong> : Get to know eachother, discuss time constraints, goals, etc.</li>
<li><strong><code>Start Coding</code></strong> : Drivers code, Navigators Guide.</li>
<li><strong><code>Hand Off</code></strong> : App Academy employs a 15 min. interval.</li>
<li><strong><code>Follow-Up</code></strong> : The last check in, this is a good time wrap up and review your code. This step helps commit your progress to memory.</li>
</ul>
<hr />
</body>
</html>
