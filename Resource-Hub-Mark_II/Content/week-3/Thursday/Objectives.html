<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Objectives</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="objectives"><strong>Objectives</strong></h1>
<h2 id="recursion"><strong>Recursion</strong></h2>
<p><strong>1. Given a recursive function, identify what is the base case and the recursive case.</strong></p>
<p><strong>2. Explain when a recursive solution is appropriate to solving a problem over an iterative solution.</strong></p>
<ul>
<li>One should consider recursion when:
<ul>
<li>Inputs are unpredictable, large, or highly complex.</li>
</ul></li>
</ul>
<p><strong>3. Write a recursive function that takes in a number, n, argument and calculates the n-th number of the Fibonacci sequence.</strong></p>
<pre><code>const fibo = (n) =&gt; {
  if (n &lt;= 2) {
    return 1;
  }
  return fibo(n - 1) + fibo(n - 2);
};</code></pre>
<p><strong>4. Write a function that calculates a factorial recursively.</strong></p>
<pre><code>const factorial = (n) =&gt; {
  if (n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
};</code></pre>
<p><strong>5. Write a function that calculates an exponent (positive and negative) recursively.</strong></p>
<pre><code>const expo = (n, p) =&gt; {
  if (p &lt; 0) {
    return 1 / expo(n, Math.abs(p - 1));
  }
  if (p === 1) {
    return n;
  }
  return n * expo(n, p - 1);
};</code></pre>
<p><strong>6. Write a function that sums all elements of an array recursively.</strong></p>
<pre><code>const sum = (arr) =&gt; {
  if (arr.length === 1) {
    return arr[0];
  }
  return arr[0] + sum(arr.slice(1));
};</code></pre>
<p><strong>7. Write a function that flattens an arbitrarily nested array into one dimension.</strong></p>
<pre><code>const flatten = (arr) =&gt; {
  let newArr = [];
  arr.forEach(function (subArr) {
    if (Array.isArray(subArr)) {
      newArr.push(...flatten(subArr));
    } else {
      newArr.push(subArr);
    }
  });
  return newArr;
};</code></pre>
<p><strong>8. Given a buggy recursive function that causes a RangeError: Maximum call stack and examples of correct behavior, debug the function.</strong></p>
<ul>
<li>Best way to debug a recursive function that is infinitely looping is to add a base case and recursive step.</li>
</ul>
<hr />
</body>
</html>
