<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="promises-in-javascript">Promises in JavaScript</h1>
<ul>
<li><code>Promise</code> in JavaScript - a commitment that sometime in the future, your code will get <code>a value</code> or <code>an error</code> from some operation
<ul>
<li>examples for values: reading a file or getting JSON from a Web site</li>
<li>examples for errors: the file doesn’t exist or the Web site is down</li>
</ul></li>
<li>A <code>Promise</code> is a JavaScript class that we can create promises from</li>
</ul>
<h2 id="three-states-of-promises">Three States of Promises</h2>
<ol type="1">
<li><code>Pending</code> - the Promise object has not resolved. Once it does, the state of the Promise object may transition to either the fulfilled or rejected state.</li>
<li><code>Fulfilled</code> - Whatever operation the Promise represented succeeded and your success handler will get called. Now that it’s fulfilled, the Promise:
<ul>
<li>must not transition to any other state.</li>
<li>must have a value, which must not change.</li>
</ul></li>
<li><code>Rejected</code> - Whatever operation the Promise represented failed and your error handler will get called. Now that it’s rejected, the Promise:
<ul>
<li>must not transition to any other state.</li>
<li>must have a reason, which must not change.</li>
</ul></li>
</ol>
<h2 id="promise-syntax">Promise Syntax</h2>
<ul>
<li><p>create a <code>new Promise</code></p>
<p>const myPromise = new Promise((resolve, reject) =&gt; { // resolve() // invoking resolve will change state from pending to resolved // reject() // invoking reject will change state from pending to rejected });</p></li>
<li><code>.then</code> is an instance method for a <code>Promise</code>
<ul>
<li>first argument is expected to be a callback function that will be invoked when the promise is resolved, return value is passed into the next <code>.then</code></li>
<li>second argument is expected to be a callback function that will be invoked when the promise is rejected</li>
</ul>
<p>myPromise .then((resolveArg) =&gt; { // resolveArg is the argument that gets passed into the resolve function in the promise // executed when promise is resolved }, (rejectArg) =&gt; { // rejectArg is the argument that gets passed into the reject function in the promise // executed when promise is rejected });</p></li>
<li><p><code>.then</code> can be chained on a <code>Promise</code> that will be executed one right after the other</p>
<p>myPromise .then(() =&gt; ‘hello world!’) .then(() =&gt; ‘after hello world’);</p></li>
<li><code>.catch</code> is an instance method on a <code>Promise</code> to catch errors on any part of the promise or the <code>.then</code> chain
<ul>
<li>argument passed in is expected to be a callback function</li>
</ul></li>
</ul>
<h2 id="learning-objectives">Learning Objectives</h2>
<ol type="1">
<li>Instantiate a <code>Promise</code> object</li>
<li>Use <code>Promise</code>s to write more maintainable asynchronous code</li>
<li>Use the <code>fetch</code> API to make <code>Promise</code>-based API calls</li>
</ol>
</body>
</html>
