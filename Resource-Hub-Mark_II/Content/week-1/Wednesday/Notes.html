<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Notes</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="notes"><strong>Notes</strong></h1>
<h2 id="function-expressions"><strong>Function Expressions</strong></h2>
<p>We want to further our thinking of functions as expressions that can be stored in variables - just like other data types!</p>
<hr />
<h2 id="functions-as-first-class-objects"><strong>Functions as first-class objects</strong></h2>
<ul>
<li><p><strong>First-class objects</strong> : a fancy term that indicates we can treat functions as “normal” values which can be stored inside variables.</p>
<pre><code>let calculateAverage = function (a, b) {
  return (a + b) / 2;
};

console.log(calculateAverage(10, 20)); // 15</code></pre>
<ul>
<li>Now we can call the function by simply stating the variable name.</li>
<li>Note one of the major differences is that we do not write the name of the function after the function keyword.</li>
<li>This is called <strong>Function Expression</strong> vs <strong>Function Declaration</strong></li>
<li>(<strong>Extra Info</strong>) We typically choose Function Decalarations if we’d like to use our functions globally, whereas Expressions would be preferable if you’d like to keep your global scope light and maintain clean syntax.</li>
</ul></li>
<li><p>Function Expressions are labeled as Expresssions b/c when we assign expressions to variables such as:</p>
<pre><code>let myNum = 4 + 4;
console.log(myNum); // 8</code></pre></li>
<li>The expression evaluates to a single value, our Function Expressions evaluates in the same way.</li>
<li><p>We can further illustrate how the function is truly stored as a variable when we call the name of the function without paramaters.</p>
<pre><code>let myFunc = function () {
  console.log(&quot;Hello&quot;);
};

console.log(myFunc); // =&gt; prints [Function: myFunc]</code></pre></li>
<li><strong>Anonymous Function</strong> : Term used to describe a function expression before it is assigned to any variable.
<ul>
<li>Uses: If a function is used only once, or a limited amount of times, an anonymous function may be syntactically lighter than using a named function.</li>
</ul></li>
<li><p>Don’t forget to add semi-colon after function expression!</p></li>
</ul>
<hr />
<h2 id="two-dimensional-arrays"><strong>Two Dimensional Arrays</strong></h2>
<p><strong>Multidimensional Arrays</strong></p>
<p>When we store arrays as elements of other arrays we call them <strong>multidimensional arrays</strong></p>
<pre><code>let twoDArray = [
  [1, 2, 3],
  [4, 5, 6],
];

console.log(twoDArray[1]); // [1,2,3]
console.log(twoDArray[1][0]); // 1</code></pre>
<ul>
<li>We can simply add a second pair of brackets to directly access the data inside a nested array with a given index.</li>
</ul>
<p><strong>Iterating through 2D Arrays</strong></p>
<ul>
<li><p>In order to access and iterate 2D Arrays, we can use a <strong>double for loop</strong>.</p>
<pre><code>let array = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

for (var i = 0; i &lt; array.length; i++) {
  let subArr = array[i];
  for (var j = 0; j &lt; subArr.length; j++) {}
}</code></pre></li>
<li>Convention is to denote j after i, k after j, etc.. when choosing a letter for index. (Careful to not repeat them within your functions, it will mess everything up!)</li>
<li><p>To break down what is happening in a double for loop,here is a helpful illustration: <img src="https://cdn.discordapp.com/attachments/222504021074640898/732723364111581245/image0.jpg" alt="pic of double for loop" /></p></li>
</ul>
<hr />
<p><strong>When is a 2D array practical?</strong></p>
<ul>
<li>Just keep in mind 2D arrays will be very useful for “grids”</li>
<li>Think: Tic-Tac-Toe, Chess, Sudoku, Excel</li>
</ul>
<hr />
<h2 id="mutability"><strong>Mutability</strong></h2>
<p><strong>Mutability</strong> : The ability to change. (mutable and immutable)</p>
<p><em>When we refer to mutability in JS we are looking to see which methods will modify existing data and which methods do not.</em></p>
<p><strong>What is mutability?</strong> One way in which Strings and Arrays differ, is that String data is immutable.</p>
<pre><code>let myArr = [&quot;b&quot;, &quot;e&quot;, &quot;a&quot;, &quot;m&quot;];
myArr[0] = &quot;s&quot;;
console.log(myArr); // &#39;seam&#39;

let myStr = &quot;beam&quot;;
myStr[0] = &quot;s&quot;;
console.log(myStr); // &#39;beam&#39;</code></pre>
<ul>
<li><p>There are some arrray methods that will manipulate array data, but there are <strong>ZERO</strong> methods that will manipulate strings.</p>
<p>let word = “piñata”; let newWord = word.toUpperCase(); console.log(word); // ‘piñata’ console.log(newWord); // ‘PIÑATA’</p></li>
<li><p>The .toUpperCase() method is not actually altering the original string data.</p></li>
</ul>
<p><strong>Mutable or Immutable, that is the Question</strong></p>
<table>
<thead>
<tr class="header">
<th>
Mutable
</th>
<th>
Immutable
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
Array
</td>
<td>
Number
</td>
</tr>
<tr class="even">
<td>
Object
</td>
<td>
String
</td>
</tr>
<tr class="odd">
<td>
</td>
<td>
Boolean
</td>
</tr>
</tbody>
</table>
<ul>
<li>Quick rule of thumb here it remember data types that can store <strong>multiple values</strong> are mutable, <strong>singular value</strong> data types are immutable!</li>
</ul>
<p><strong>The mutability misconception</strong></p>
<pre><code>let myNum = 42;
myNum += 8;
console.log(myNum); //59</code></pre>
<ul>
<li>Our number data is not actually being changed, we are simply re-assigning our variable with a new number because myNum += 8 =&gt; myNum = myNum + 8.</li>
</ul>
<hr />
<h2 id="array-splice-method"><strong>Array Splice Method</strong></h2>
<p><strong>What can Array.splice do?</strong></p>
<ul>
<li>This method will mutate our array, not return a new array.</li>
<li>It is used to remove and insert elements into an array.</li>
<li><p>array.splice(starting index, # of items to remove, element to replace slice)</p>
<p>let colors = [“red”, “yellow”, “blue”, “green”, “orange”, “brown”, “gray”]; let returnVal = colors.splice(2, 3);</p>
<p>console.log(colors); // [ ‘red’, ‘yellow’, ‘brown’, ‘gray’ ] console.log(returnVal); // [ ‘blue’, ‘green’, ‘orange’ ]</p></li>
<li>If we only populate the first two parameters, we simply just ‘slice’ out a portion of our array.</li>
<li><p>If we assign a variable to our slice method we can store the ‘sliced’ out data.</p></li>
</ul>
<p><strong>Using splice to insert</strong></p>
<pre><code>let colors = [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;];
let returnVal = colors.splice(1, 1, &quot;RebeccaPurple&quot;, &quot;CornflowerBlue&quot;);

console.log(colors); // [ &#39;red&#39;, &#39;RebeccaPurple&#39;, &#39;CornflowerBlue&#39;, &#39;blue&#39; ]
console.log(returnVal); // []</code></pre>
<ul>
<li>As you can see, by adding beyond the first two arguments, we can add new elements into the area we intially removed data.</li>
</ul>
<hr />
<h2 id="split-and-join-methods"><strong>Split and Join Methods</strong></h2>
<p><strong>String.split</strong></p>
<p>Method that can be called on a string and uses a “separator” string as an argument.</p>
<pre><code>let sentence = &quot;follow the yellow brick road&quot;;

console.log(sentence.split(&quot; &quot;)); // [ &#39;follow&#39;, &#39;the&#39;, &#39;yellow&#39;, &#39;brick&#39;, &#39;road&#39; ]

console.log(sentence.split(&quot;the&quot;)); // [ &#39;follow &#39;, &#39; yellow brick road&#39; ]

console.log(sentence.split(&quot;o&quot;)); // [ &#39;f&#39;, &#39;ll&#39;, &#39;w the yell&#39;, &#39;w brick r&#39;, &#39;ad&#39; ]</code></pre>
<ul>
<li>The argument for this method indicates what character(s) to split our string on. In the above example you can see our string being split on spaces, “the”, and “o”.</li>
<li>Pro Tip: Good for removing certain repeated words from data.</li>
</ul>
<p><strong>Array.join</strong></p>
<p>Method that can be called on an array and uses a “joiner” string as as argument.</p>
<pre><code>let words = [&quot;run&quot;, &quot;around&quot;, &quot;the&quot;, &quot;block&quot;];
let sentence = words.join(&quot; &quot;);
console.log(sentence); // &#39;run around the block&#39;
console.log(words); // [ &#39;run&#39;, &#39;around&#39;, &#39;the&#39;, &#39;block&#39; ]

console.log(words.join(&quot;_&quot;)); // &#39;run_around_the_block&#39;
console.log(words.join(&quot;HI&quot;)); // &#39;runHIaroundHItheHIblock&#39;</code></pre>
<ul>
<li>Works same aay as string.split but we are joining our array on an argument. (FYI this method <strong>does not</strong> mutate original array data!)</li>
</ul>
<p><strong>Clever Combination</strong></p>
<p>We can combine these two methods to accomplish cool behavior! (will be really useful for future problem solving by changing strings to arrays and back)</p>
<pre><code>let str = &quot;I don&#39;t know what I want to eat&quot;;
let newStr = str.split(&quot;I&quot;).join(&quot;we&quot;);
console.log(newStr); // &#39;we don&#39;t know what we want to eat&#39;</code></pre>
<hr />
<h2 id="array-push-pop-shift-unshift"><strong>Array Push, Pop, Shift, Unshift</strong></h2>
<p><strong>Array Methods</strong> (These methods all <em>mutate</em> our original array.)</p>
<ul>
<li><strong>Push</strong> : adds element(s) to end of array.</li>
<li><strong>Pop</strong> : removes ONE element from end of array.</li>
<li><strong>Shift</strong> : removes ONE element from start of array.</li>
<li><strong>Unshift</strong> : adds element(s) to the start of the array.
<ul>
<li><p>If we console.log() any of these methods, it will print out the element that is being added/removed.</p>
<p>let array = [1, 2, 3, 4, 5]; array.pop(); console.log(array); // [1, 2, 3, 4] console.log(array.pop()); // 5</p></li>
<li><p>It’s important to note that Push &amp; Unshift (methods that add elements) can be used to add multiple elements at a time, Pop &amp; Shift can only remove on element when used by themselves.</p></li>
</ul></li>
</ul>
<hr />
<h2 id="pairs-in-arrays-unique-pairs"><strong>Pairs in Arrays &amp; Unique Pairs</strong></h2>
<p>One of the handy uses of double for loops is that we can use them to find pairs of data.</p>
<pre><code>let cats = [&quot;Bob&quot;, &quot;Fluffy&quot;, &quot;Whiskers&quot;, &quot;Fred&quot;, &quot;Happy&quot;];

function playdate(cats) {
  for (var i = 0; i &lt; cats.length; i++) {
    for (var j = i + 1; j &lt; cats.length; j++) {
      console.log([cats[i], cats[j]]);
    }
  }
}

playdate(cats); // =&gt;
[&quot;Fluffy&quot;, &quot;Whiskers&quot;][(&quot;Fluffy&quot;, &quot;Happy&quot;)][(&quot;Whiskers&quot;, &quot;Happy&quot;)];</code></pre>
<ul>
<li>By using a double for loop we were able to go through all the cats in our array and match them up for playdates.</li>
<li>By using the handy trick of setting our starting value of (var j = i + 1) we are able to avoid duplicate playdates with the other cats and ensuring no scheduled playdates by themselves!</li>
</ul>
<hr />
<h2 id="splice-vs-slice"><strong>Splice vs Slice</strong></h2>
<p><a href="https://www.tothenew.com/blog/javascript-splice-vs-slice/#:~:text=The%20splice()%20method%20returns,as%20a%20new%20array%20object.&amp;text=The%20splice()%20method%20changes,t%20change%20the%20original%20array.">Click to Read More</a></p>
<table>
<thead>
<tr class="header">
<th>
Splice
</th>
<th>
</th>
<th>
Slice
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>
Changes Original Array
</td>
<td>
</td>
<td>
Doesn’t Change Original Array
</td>
</tr>
<tr class="even">
<td>
Takes n arguments
</td>
<td>
</td>
<td>
Only takes two arguments
</td>
</tr>
<tr class="odd">
<td>
Arg1: Starting index
</td>
<td>
</td>
<td>
Arg1: Starting index
</td>
</tr>
<tr class="even">
<td>
Arg2 (Optional): # of Elements to Remove
</td>
<td>
</td>
<td>
Arg 2: Ending index
</td>
</tr>
<tr class="odd">
<td>
Arg… (Optional): Element(s) to insert
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Best way to differentiate is, <strong>SLICE</strong> takes a slice of the array by indicating a start and end, <strong>SPLICE</strong> removes elements from a starting point based on how many elements you indicate in arg2 to delete from the start (<em>if you only pass the first required arg into splice, it will just chop off data from the start to the end)</em></p>
<p>let cats = [“Fluffy”, “Whiskers”, “Happy”]; cats.slice(1, 3); console.log(cats); console.log(cats.slice(1, 3));</p>
<p>let cats = [“Fluffy”, “Whiskers”, “Happy”]; cats.splice(1, 2); console.log(cats);</p></li>
</ul>
<hr />
</body>
</html>
